# XML i veb servisi

## Sadrzaj
- [Inzenjering dokumenata](#inzenjering-dokumenata)
- [Markup jezici i XML](#markup-jezici-i-xml)
- [Document Type Definition (DTD)](#document-type-definition)
- [XML Namespaces](#xml-namespaces)
- [XML Schema](#xml-schema)
- [XML Parseri](#xml-parseri)
- [StAX](#stax)
- [SAX](#sax)
- [DOM](#dom)
- [JAXB](#jaxb)
- [XPath](#xpath)
- [XQuery](#xquery)
- [Vizuelizacija XML Dokumenta](#vizuelizacija-xml-dokumenta)
- [CSS](#css)
- [XSLT](#xslt)
- [XSL-FO](#xsl-fo)
- [RDF](#rdf)
- [RDFS](#rdfs)
- [SPARQL](#sparql)
- [Biznis procesi](#biznis-procesi)
- [SOA](#soa---service-Oriented-Architecture)
- [SOAP](#Web-servisi-i-SOAP-protokol)
- [WSDL](#wsdl)
- [UDDI](#uddi)
- [Mikroservisi](#mikroservisi)


## Inzenjering dokumenata

- dokumenti i poslovni procesi
- analiza, dizajn i implementacija informacionih sistema
    - smanjeno vreme troskova
    - integracija i interoperabilnost
- **dokument**: fiksna i strukturirana kolicina informacija kojom se upravlja kao jedinicom i koja se razmnenjuje kao jedinica izmedju korisnika i sistema
    - zivotni ciklus
    - jako strukturirani - slabo strukturirani
    - sadrzaj + struktura + prezentacija (ref="XML.pdf/15")
- **identifikator** je objekat(skup metapodataka) koji moze da sluzi kao referenca na nesto sto ima identitet
- **poslovni proces** je skup aktivnosti(transformacija) ulaz -> izlaz -> cilj
    - rucno ili automatski
- **sistemi za upravljanje dokumentima** upravljaju zivotnim ciklusom dokumenta
    - rad sa dokumentima
    - rad sa metapodacima
    - indeksiranje i pretraga dokumenata
    - definisanje poslovnih procesa
    - saradnja izmedju korisnika
    - upravljanje verzijama dokumenta
    - bezbednost
    - integracija sa drugim sistemima
- Za implementaciju sistema za upravaljanje dokumentima koriste se**sistemi za upravljanje radnim tokovima**
    - dokument kao centar radnog toka
    - definisanje, izvrsavanje i nadgledanje radnih tokova
    - bazirani na dokumentima
- **resurs** moze biti bilo sta sto ima identitet
    - npr: elektronski dokument, slika, servis, kolekcija resursa
    - informacioni resursi se mogu preneti u poruci
    - neinformacioni resursi su oni drugi
- **reprezentacija resursa** je informacija koja reflektuje proslo, trenutno ili zeljeno stanje resursa, u formatu koji moze da se lako komunicira putem protokola i koja se sastoji iz skupa reprezentactionih metapodataka i potencijalno neogranicenim tokom reprezentacionih podataka
    - svaki resurs moze da ima vise reprezentacija
- **URI (Uniform resource identifier)** je niz znakova za identifikovanje apstraktnih ili fizickih resursa
    - URL, URN, ili oba
    - URI sema definise prostor imena identifikatora i moze dalje da ogranici sintaksu i semantiku identifikatora
- **URL (Uniform resource locator)** je podskup URI koji identifikuje resurse preko reprezentacije njihovog primarnog mehanizma pristupa
- **URN (Uniform resource name)** je podskup URI koji mora ostati globalno jedinstven i perzistentan cak i ako resurs prestane da postoji ili postane nedostupan
- **HTTP**
    - sigurne metode (ne menjaju stanje servera)
    - idempotentne metode (vise identicnih zahteva ima isti efekat kao jedan)
    - kodovi:
        - 1xx - info
        - 2xx - success
        - 3xx - redirect
        - 4xx - client error
        - 5xx - server error
- **informacioni set** skup elemenata i njihovih veza (stablo)
    - **RDF** graf (vise o tome kasnije :)


## Markup jezici i XML
- **markup** (tag, code) oznaka koja opisuje deo sadrzaja
    - koriscen i na papiru (naslov, citati...)
    - ne predstavlja sadrzaj
    - uputstvo kako obraditi sadrzaj
    - ne prikazuje se eksplicitno (krajnji korisnik ne vidi markup tagove)
    - ako se korisiti za definisanje prezentacije dokumenta vidljiv (broj poglavlja, naslov, broj strane)
    - definisu ih:
        - firme
        - otvoreni standardi
    - rad se vise markup istovremeno je tehnicki komplikovan i trazi puno rucnog rada
    - korišćenje otvorenih standarda bi trebalo da pojednostavi razmenu podataka između razlicitih sistema, softvera i/ili ucensnika u proizvodnji sadrzaja
    - nejasan markup (osnovni razlozi nastanka su fokus na prikaz dokumenta i ogranicenost na spostveni, zatvoren sistem)
    - otvoreni standardi za markup se fokusiraju na markiranje *strukture* i *znacenja*
- **HTML**
    - hijerarhija elemenata
    - unapred definisani tagovi
    - definisan pomocu XML-a
- **XML** (eXtensible Markup Language)
    - ne definise tagove unapred (korisnik ih sam definise)
    - jezik za definisanje markup jezika
    - ciljevi
        - da odgovara upotrebi na Internetu
        - mogućnost korišćenja od strane različitih aplikacija
        - (jednosmerna) kompatibilnost sa SGML-om (Standard Generelized Markup Language)
        - da se programi za obradu XML dokumenata pišu lako
        - jednoznačnost prilikom obrade XML dokumenata
        - XML dokumenti čitki i rezonski jasni
        - dizajn XML-a se vrši brzo
        - dizajn XML-a je formalan i koncizan
        - kreiranje XML dokumenata je lako
        - konciznost je od minimalne važnosti
    - familija standarda
        - XSL (Extensible Stylesheet Language)
            - XSLT (Transformations)
            - XSL-FO (Formatting Objects)
        - XPath (oznacavanje strukture)
        - XLink (povezivanje)
        - XQuery (pretrazivanje)
- **element** je cvor u hijerarhijskoj strukturi dokumenta (moze sadrzati druge cvorove)
    - **tag** je tekstualna oznaka (markup) za pocetak ili kraj elementa
        - pocenti (otvarajuci) tag `<tag>`
        - zavrsni (zatvarajuci) tag `</tag>`
    - **sadrzaj** elementa se nalazi izmedju pocetnoh i zavrsnog taga
        - tekst
        - podelementi
        - mesavina
        - prazan
    - ako je prazan moze da se spoji \<tag/>
    - element moze da ima atribute
- **atribut**
    - naziv
    - sadrzaj (nestrukturiran tekst)
    - najcesce se smatrja posebnim cvorom stabla
- dobro formirani XML dokument (moze masinski da se obradi)
    - ima jedan korenski element
    - elementi se mogu ugnjezdavati ali ne i preklapati
    - vrednosti atributa moraju biti unutar navodnika
    - element ne moze imati dva atributa sa istim imenom
    - komentari i procesne instrukcije se ne smeju nalaziti unutar
taga
- generalna pravila
    - elementi - podaci; kada nismo sigurni; lakse se prilagode
    - atributi - metapodaci; ne mogu se strukturirati
- davanje imena elementima i atributima
    - case sensitive
    - slova, cifre, "_", "-", ":" i "."
    - mora poceti sa slovom ili "_"
    - ne sme poceti sa *xml*
- ostali delovi XML dokumenta
    - **komentari**
        - navode se izmedju `<!-- i --\>`
        - ignorisu se kao sadrzaj (ne prikazuju se, ne obradjuju se programski)
        - bilo gde izvan taga
    - **procesne instrukcije**
        - navode se izmedju `<? i ?>`
        - predstavljaju instrukcije softveru
        - nisu namenjene krajnjem korisniku (čoveku)
        - nisu deo sadržaja dokumenta
        - mogu se nalaziti bilo gde izvan taga
        - xml deklaracija na pocetku dokumenta 
        `<?xml **version**="1.0" **encoding**="utf-8" **standalone**="yes"?>`
    - **entiteti**
        - ugradjeni (unapred definisani)
        - \&lt; = &lt;
        - \&amp; = &amp;
        - \&gt; = &gt;
        - \&quot; = &quot;
        - \&apos; = &apos;
    - **CDATA sekcije**
        - navode se izmedju `<![CDATA[i]]>`
        - sadrzi tekst koji se interpretira direktno, bez zamene entiteta


## Document Type Definition
- **DTD** fajl (dokument) opisuje format klase/familije/tipa XML dokumenata
    - koji elementi i entiteti se mogu pojaviti na kom mestu u dokumentu
    - sta je sadrzaj element i atributa
    - dokument je validan ako odgovara svom DTD-u
- **deklaracija elementa**
    - opsti oblik `<!ELEMENT naziv (specifikacija_sadržaja)>`
    - naziv postuje pravila imena elemenata i atributa
- **specifikacija sadrzaja elementa**
    -  #PCDATA
        - sadrzaj elementa je tekst, bez podelemenata
        - tekst je parsiran (reference na entitete su razresene)
        - primer `<!ELEMENT phone_number (#PCDATA)>`
    - sekvenca podelemenata
        - podelementi se razdvajaju zarezom
        - uz naziv podelementa navodi se oznaka broja ponavljanja 
            - ? = (0..1)
            - \* = (0..∞)
            - \+ = (1..∞)
            - podrazumevano = (1..1)
        - redosled i broj ponavljanja podelemenata su bitni
        - primer: `<!ELEMENT name (first_name, last_name?)>`
    - izbor
        - podelementi se razdvajaju uspravnom crtom
        - izbor moze obuhvatati 2+ podelementa
        - primer: `<!ELEMENT methodResponse (params | fault)>`
    - upotreba zagrada
        - sekvence, izbori i sufiksi se mogu kombinovati
    - mesani sadrzaj
        - element sadrzi i tekst i podelemente
        - definise se kao izbor ciji prvi element je #PCDATA, ostali lementi su moguci podelementi, a cela grupa ima broj ponavljanja \*
        - primer: `<!ELEMENT definition (#PCDATA | term)*>`
        - nije moguce navesti broj niti redosled ponavljanja podelemenata i teksta
        - deklaracija mesanog sadrzaja se ne moze koristiti za dalje grupisanje
    - prazan sadrzaj
        - kljucna rec *EMPTY*
        - primer: `<!ELEMENT img EMPTY>`
    - bilo kakav sadrzaj
        - oznacava se kljucnom reci *ANY*
        - uključuje tekst, podelemente, isti element ponovljen rekurzivno
        - nalik mešanom sadržaju bez fiksirane liste podelemenata
        - podelementi koji se pojavljuju u sadržaju moraju biti deklarisani
        - u praksi se koristi samo u toku razvoja DTD-a
        - primer: `<!ELEMENT page ANY>`
- **deklaracija atributa**
    - opsti oblik: `<!ATTLIST imeElementa imeAtr tipAtr default>`
    - naziv atributa mora da odgovara pravilima za formiranje imena
    - tip atributa se bira iz konačnog skupa
    - obaveznost atributa se bira iz konačnog skupa
    - jedna deklaracija može da obuhvati više atributa jednog elementa
        - u praksi se svi atributi jednog elementa stavljaju u jednu deklaraciju
        - u praksi se deklaracija atributa navodi odmah ispod deklaracije elementa
    - moguci tipovi
        - CDATA: bilo koji dobro formirani tekst
        - NMTOKEN: XML name token
        - NMTOKENS: jedan ili više NMTOKEN-a razdvojenih razmacima
        - nabrajanje mogućih vrednosti (delimiter "|")
        - ID: string koji je XML ime i jedinstven je u okviru celog dokumenta (samo jedan ID po elementu)
        - IDREF: postojeca vrednost ID atributa nekog elementa u istom dokumentu
        - IDREFS: niz IDREF vrednosti razfvojenih razmakom
        - ENTITY: ime neparsiranog entiteta koje je deklarisan u DTD-u
        - ENTITIES: više ENTITY vrednosti razdvojenih razmakom
        - NOTATION: sadrži ime notacije koja je deklarisana u DTD-u
    - obaveznost pojavljivanja atributa
        - \#IMPLIED: atribut nije obavezan; može se navesti ali i ne mora
        - \#REQUIRED: atribut je obavezan; mora se navesti
        - \#FIXED "value" : atribut nije obavezan, ali se smatra da uvek postoji u elementu i da ima datu fiksnu vrednost value; ako se eksplicitno navede u elementu, mora imati baš tu vrednost
        - "default": atribut, ako se ne navede, ima podrazumevanu vrednost default datu pod navodnicima
- **deklaracija entiteta** - pored predefinisanih, moguce je deklarisati nove
    - opsti oblik `<!ENTITY naziv "sadržaj">`
    - svaki "naziv" u dokumentu bice zamenjeno sadrzajem, prilikom parsiranja (ucitavanja) XML dokumenta
    - sadrzaj entiteta moze da sardzi druge entitete (bez rekurzije)
    - eksterni entitet - smesten u posebnom fajku, izvan DTD-a
        - opsti oblik eksternog: `<!ENTITY naziv SYSTEM "adresa_fajla">`
    - moze imati javni identifikator `<!ENTITY name PUBLIC "pubid" SYSTEM "sysid">`
        - javni identifikator može da identifikuje dobro poznati resurs (iz liste takvih) koji je javno dostupan
        - liste javno dostupnih resursa su slabo razvijene
        - retko se koriste
    - parametarski entiteti - entiteti koji se definisu za potrebe DTD-a a ne XML dokumenta
        - opsti oblik: `<!ENTITY % ime "vrednost">` ili `<!ENTITY % ime "vrednost">`
    - neparsirani entiteti - fajlovi koji sadrze ne-XML podatke
        - opsti oblik `<!ENTITY naziv PUBLIC "pubid" notacija>` ili `<!ENTITY naziv SYSTEM "sysid" notacija>`
        - referenca na neparsirani entitet može se naći samo kao vrednost atributa tipa ENTITY
        - notacija predstavlja dodatnu informaciju za XML aplikaciju kako da rukuje podacima iz neparsiranog entiteta
- **deklaracija notacije**
    - notacija = pomocni podaci za XML aplikaciju prilikom rukovanja sa neparsiranim entitetima
    - opsti oblik `<!NOTATION naziv PUBLIC "pubid">` ili `<!NOTATION naziv SYSTEM "sysid">`
    - nema standarda niti preporuke kako treba da izgledaju notacije, sve je stvar aplikacije
- **povezivanje XML dokumenta sa DTD-om**
    - takozvani prolog XML dokumenta sadrzi
        - XML deklaraciju
        - deklaraciju tipa dokumenta koja povezuje dokument sa DTD-om
    - opsti oblik `<!DOCTYPE koren (PUBLIC "pubid" | SYSTEM) "sysid" [<!-- interne deklaracije -->]>`
    - uslovne sekcije INCLUDE i IGNORE


## XML Namespaces
- svako moze da definise sopstvenu XML gramatiku
- ukoliko zelimo da koristimo razlicite gramatike moze doci do poklapanja imena
- resenje:
    - uciniti da sva imena budu jedinstvena
    - mozemo svakom elementu dodati prefiks (zavisno od toga gde su definisani)
- skup elemenata sa istim prefiksom je **prostor imena** (namespace)
    - prostor imena ≠ tip dokumenta
    - jedan tip dokumenta moze ukljucivati elemente iz vise prostora
    - jedan element moze biti koriscen u vise tipova dokumenata
- koncept prefiksa nije dovoljno robustan
    - vise ljudi moze da se odluci da koristi isti prefiks
    - morala bi da postoji organizacija koja se bavi administarcijom prefiksa
- koristimo postojeci sistem - internet
    - prostori imena identifikuju se nazivom
    - naziv = URI
    - URL je pogodniji od URN
        - lakse je napraviti jedinstveni URL (npr. firma vec poseduje domen)
        - zloupotreba tudjeg domena se ne moze izbeci, izbegavaju se slucajne kolizije
        - DTD se moze postaviti na taj URL i time uciniti javno dostupnim
        - koristi se puna adresa (`http://www.mojafirma.com/primer` ≠ `http://mojafirma.com/primer`)
    - identifikator prostora imena ne mora da nosi nikakvo znacenje
    - `http://www.mojafirma.com/primer:name` je predugacko i nezgrapno (moze da narusi pravila imena)
- **kvalifikovano ime** (qualified name, QName)
    - lokalno ime + namespace
    - umesto punog naziva namespace-a, koristi se prefiks (XML dozvoljen)
    - prefiks se povezuje sa svojim prostorom imena
    - ime prefiksa vise nije bitno
    - primer: `xmlns:pers="http://www.ftn.ns.ac.yu/dtds/person.dtd"`
    - **podrazumevani** prostor imena
        - njegovi elemeni se navode bez prefiksa
        - primer `xmlns="http://www.ftn.ns.ac.yu/dtds/person.dtd"`
    - u jednom dokumentu moze se koristiti vise prostora imena
        - prefiksi imaju znacenje samo u *okviru*(element + podelementi) elementa u kom se nalaze
        - namespace mozemo iskljuciti xmlns=""
    - prefiks se moze koristiti i ispred atributa
        - aplikacija to interpretira po volji
- sto se tice XML aplikacije je svejedno koji pristup koristimo:
    - uvek koristiti prefiks
    - koristiti jedan defaut namespace, ostali sa prefiksom
    - svuda redefinisati namespace
- namespace i DTD
    - DTD je definisan pre XML Namespaces standarda
    - DTD ne podrzava namespaces potpuno
    - elementi se moraju definisati sa prefiksom koji je unapred fiksan
    - namespace deklaracije se tretiraju kao atributi (nije svejedno gde deklarisemo namespace)


## XML Schema
- sta nije dobro kod DTD?
    - ne-XML sintaksa, cudna
    - slaba podrska za namespace
    - nema tipizacije podataka (narocito lose za sadrzaj elementa)
    - ogranicena prosirivost
    - ogranicene mogucnosti za opisivanje strukture podataka
        - ne može se nametnuti broj podelemenata bez nametanja redosleda
        - ne može se nametnuti redosled i broj podelemenata kada se koristi mešani sadržaj
- **XML Schema** je XML dokument koji opisuje strukturu drugih dokumenata
    - prevazilazi mane DTD-a (DTD i dalje moze da se koristi)
    - postoji vise standarda
    - XML Schema standard propisuje W3C
        - najrasireniji, najmocniji, najkomplikovaniji
        - nema patent ili druge restrikcije
- povezivanje šeme sa dokumentom
    - standardni XML Instance namespace
        - identifikator je `http://www.w3.org/2001/XMLSchema-instance`
        - uobicajeni prefiks je *xsi*
        - cetiri atributa (*xsi:type, xsi:nil, xsi:schemaLocation, sxi:noNamespaceSchemaLocation*)
    - atribut *xsi:schemaLocation* oznacava lokaciju seme koja se definise za dati dokument
        - identifikator namespace-a + adresa fajla
    - atribut *xsi:noNamespaceSchemaLocation* oznacava lokaciju seme za default namespace
    - *target namespace* u `<schema>` elementu
        - u XSD fajlu targetNamespace atribut treba da gadja URL namespace
        - default moze da bude XMLSchema a moze i targetNamespace
        - ako ne se navede targetNamespace nema prefiksa i sve pripada default namespace-u
- cetiri osnovna elementa seme
    - *xsd:element* deklarise element i dodeljuje mu tip
    - *xsd:attribute* deklarise atribut i dodeljuje mu tip
    - *xsd:simpleType* definise novi prosti tip
    - *xsd:complexType* definise novi slozeni tip
- deklaracija vs definicija
    - deklarisanje - bice u instanci seme (elementi i atributi)
    - definisanje - koriste se u okviru seme (tipovi, grupe atributa, itd.)
- dekalracije mogu da budu ugnjezdene ili da se pozivaju na vec definisan tip
- definicija tipa
    - svaka deklaracija novog tipa se oslanja na neki od postojecih tipova
    - postoje tipovi ugradjeni u XML Schema Part 2: Datatypes
- **definicija novog prostog tipa**
    - prosti tip ima samo vrednost
    - novi prosti tipovi definisu se na osnovu postojecih - ugradjenih
    - **restrikcija**
        - skup mogucih vrednosti novog tipa je podskup vrednosti osnovnog
        - navode se pomocu 12 *facet-a* (length, minLength, maxLength, pattern...)
            - enumeration i pattern povezani sa or, ostali sa and
    - **lista**
        - tip koji definisemo predstavljace listu elemenata nekog tipa
        - elementi liste su razdvojeni razmacima
        - primer: `<bingo>4 9 12</bingo>`
        - nije moguce napraviti listu u listi niti listu slozenih tipova
        - *facet*-i (length, minLength, maxLength, enumeration, pattern)
    - **unija**
        - vrednost novog tipa moze biti vrednost bilo kog tipa koji je clan unije
- **deklaracija atributa**
    - atributi moraju biti prostog tipa
    - uvek na kraju, posle elementa
    - uvek ugnjezdeni u deklaraciju elementa kome pripadaju
- **definicija slozenog tipa**
    - slozeni tip pored vrednosti moze da ima atribute i podelemente
    - za podelemente koristimo jedan od **modela sadrzaja** (*sequence*, *choice*, *all*)
        - *minOccurs* i *maxOccurs* atributi svakog elementa odredjuju broj njegovog ponavljanja
    - *sequence* je sekvenca podelemenata ili drugih modela sadrazaja
        - redosled podelemenata je bitan
        - broj pojavljivanja podelemenata je bitan
        - cela sekvenca moze da se ponavlja (ima atribute minOccurs i maxOccurs)
    - *choice* - izbor jednog od podelemenata
    - *all* - neuredjeni skup
        - u sadrzaju se mogu navesti podelementi u bilo kom redosledu
        - svaki podelement se mora pojaviti tacno jednom
        - ne moze da sadrzi sekvence ili izbore
        - ne moze da bude ukljucen u sekvence ili izbore ili drugi *all*
    - *mesani tip*
        - attribut *mixed* ima vrednost *true*
        - tekst moze biti isprepletan sa podelementima
    - novi slozeni tip na osnovu postojeceh dobija se prosirivanjem ili restrikcijom
    - slozen tip moze da bude apstraktan
        - atribut *abstact="true"*
        - ne mogu postojati njegove instance
        - mogu postajti istance njegovih izvedenih tipova
- **grupisanje elemenata**
    - elementi se mogu grupisati
    - grupa ima svoje ime i moze se referencirati na drugom mestu
    - mora biti globalna i ne moze da ima atribute
- *fixed*, *default* i *nil* vrednosti
    - *fixed* i *defulat* omogucavaju da se navede prazan element
    - *nil* - atribut *nillable="true"* odnosno *xsi:nil="true"*; nije isto sto i prazan element
- **rad sa vise sema**
    - dokument moze da sadrzi elemente iz razlicitih sema
    - validacija se moze primeniti na ceo dokument ili na pojedinacne elemente
    - *lax* validacija - validator ne proverava one elemente za koje ne postoji sema
    - *strict* validacija - svi elementi moraju imati semu i biti validni po njoj
    - element `<xsd:include>`
        - pristup delovima drugih sema
        - ove seme kojima se pristupa moraju imati isti targetNamespace
        - ukoliko ukljucena sema nema namespace preuzece ga od seme u kojoj se koristi
        - isto kao da smo sve stavili u jedan fajl
    - element `<xsd:import>` sluzi za seme koje imaju razliciti targetNamespace
    - elementi `<xsd:include>` i `<xsd:import>` moraju se nalaziti ispred deklaracija elemenata/atributa i definicija tipova u šema dokumentu
    - `<any>` je bilo koji element
        - omogucava dodavanje elemenata koji ne definise data sema
        - postavljanjem atributa namespace mozemo joj dodeliti namespace (any, targetNamespace, other, local, URL)
    - `<\anyAttribute>` analogno *any* samo za atribute
- zamena elemenata
    - moguce je da se element Y u dokumentu nadje umesto elementa X
    - X se zove *head*
    - primer: 
        - `<xsd:element name="X" type="xsd:string"/>`
        - `<xsd:element name="Y" substitutionGroup="X" type="xsd:string"/>`
    - svi elementi koji pripadaju grupi moraju biti globalni
    - tip elementa zamene mora biti ili jednak tipu glave ili izveden iz njega
    - ako se prilikom deklarisanja tipa zamene ne navede tip, podrazumeva se tip glave
    - zabrana zamene radi se pomocu atributa `block="substitution"`
    - zamena elementa je tranzitivna
    - zamena elementa nije simetricna
- anotacija
    - element `<xsd:annotation>` sluzi za dokumentovanje seme
        - podelement `<xsd:documentation>` - za coveka
        - podelement `<xsd:appinfo>` - za masinu
    - mogu se smestiti ispred svake globale komponente i na pocetku lokalnih
    - `<xsd:documentation>` ima dva atributa
        - *source*: URL do fajla sa dodatnim podacima
        - *xml:lang*: jezik na kome je napisana dokumentacija
    - `<xsd:appinfo>` ima samo atribut *source*
- **jedinstvenost**
    - sadrzaj elementa moze biti jedinstven (*unique*)
    - vrednosti atributa koji nisu tipa ID mogu biti jedinstvene
    - kombinacija sadrzaja elemenata i atributa moze biti jedinstvena
    - moze se definisati opseg u kome se proverava jedinstvenost
    - element `<unique>` ima istu strukturu kao i `<key>` element
    - validator ce proveriti da li su oznacene vrednosti jedinstvene ako postoje
- **kljucevi**
    - pravi se razlika izmedju jedinstvene vrednost (*unique*) i kljuca (*key*)
    - *key* je element, atribut ili kombinacija vise njih koja:
        - uvek postoji (minOccurs>0)
        - ne moze biti nillable
        - je *unique* po vrednosti
    - element `<key>`
        - mora biti smesten unutar elementa posle definicije sadrzaja i deklaracije atributa
        - podelement `<selector>` odredjuje skup elemenata na koje se kljuc odnosi (opseg)
        - podelement `<field>` odredjuje atribut ili element cija vrednost predstavlja kljuc (ponovljiv)
        - identifikuju se [XPath-om](#xpath)
    - **referenciranje kljuceva**
        - element oznacen pomocu `<keyref>` mora sadrzati vrednost nekog atributa *key*
        - broj i tip polja u referenci na kljuc mora odgovarati broju i tipu polja u kljucu
        - polozaj odredjuje opseg jedinstvenosti
- **konflikt imena**
    - isto ime moze da se koristi za vise razlicitih elemenata
    - postoje situacije kada koriscenje istog imena nije dozvoljeno
    - imena komponenti koje se nalaze u semi su smestena u prostore simbola (*symbol space*)
    - *symbol space* odvojen za
        - definicije tipova, deklaracije elemenata i atributa
        - globalne komponente seme i svaki definisani tip
    - dozvoljeno
        - isto ime u različitim symbol spaces
        - isto ime u različitim namespaces
        - isto ime, isti symbol space, isti tip
    - zabranjeno
        - isto ime, isti symbol space, različit tip
- *namespace* ima sledece karakteristie koje ga razlikuju od *symbol space*
    - samo globalni elementi su u namespace-u
    - lokalni elementi su povezani (associated) sa globalnim
    - može postojati više atributa sa istim imenom
    - nisu smešteni svi u namespace, već su povezani sa elementima koji su u namespace-u
- kvalifikovanje elemenata
    - lokalni elementi formalno ne spadaju u targetNamespace ali su u njemu preko svoje veze sa globalnim elementima
    - element je kvalifikovan ako je asociran sa *namespace*-om
    - `elementFormDefault="qualified"` - svi elementi mogu biti kvalifikovani
    - `elementFormDefault="unqualified"` - samo globalni elementi mogu biti kvalifikovani
- kvalifikovanje elemenata u XPath izrazima
    - ako je elementFormDefault="qualified" elementi u XPath izrazima se moraju kvalifikovati, čak i kada je targetNamespace ujedno i default namespace
    - ako je elementFormDefault="unqualified" tada se elementi u XPath izrazima ne kvalifikuju

## XML Parseri
- moguce je napraviti parser koristesi tehnike naucene na programskim prevodiocima
- bolje koristiti vec gotove
    - manje posla
    - manja verovatnoca greske
- progarmski modeli za parsiranje XML dokumenata
    - streaming parseri
        - *pull* ([StAX](#stax) parseri)
        - *push* ([SAX](#sax) parseri)
    - *DOM* parseri
    - *XSL-T* parseri
- *push* parseri
    - implementiraju programski model u kome XML parser salje (gura) podatke programu koje ga koristi nailazeci na elemente XML informacionog skup (element, atribute, test, itd.)
- *pull* parseri
    - pull parseri implementiraju prgoramski model u kome programi koji ih koriste pozivaju metode XML parsera (vuku podatke) kada im treba element XML informactionog skupa
- [StAX](#stax)
    - pull streaming
    - lako upotrebljiv
    - ne podrzava [XPath](#xpath)
    - nisko zahtevni za CPU
    - cita ili pise XML
- [SAX](#sax)
    - push streaming
    - teze upotrebljiv
    - ne podrzava [XPath](#xpath)
    - nisko zahtevni za CPU
    - cita XML
- [DOM](#dom)
    - in memory tree
    - lako upotrebljiv
    - podrzava [XPath](#xpath)
    - visoko zahtevni za CPU
    - cita i pise XML
    - podrzava CRUD
- *TrAX*
    - XSLT rules
    - teze upotrebljiv
    - podrzava [XPath](#xpath)
    - visoko zahtevni za CPU
    - cita i pise XML


## StAX
- pull parser
- koristi se i za citanje i za pisanje
- XML dokumente parsira koriscenjem iteratora
- *Cursor* API koristi kursor koji se krece od pocetka do kraja XML dokumenta
- *Iterator* API predstavlja XML dokument kao niz diskretnih dogadjaja koji se mogu obraditi

## SAX
- definisan za razlicite jezike (Java, C++)
- specifikacije slicne za svaki jezik
- nije W3C standard ali je *de facto* standard
- koncept
    - parsiranje je *event-driven*
    - parser generise dogadjaje (npr. poceo dokument, poceo element, zavrsio element)
    - nas kod obradjuje dogadjaj (*handler*-i koje poziva parser putem *callback*-a)
- *handlers*
    - dogadjaji koje obradjuju: *startDocument(), endDocument(), startElement(), endElement(),
characters(), processingInstructions()*
    - *ContentHandler* (dogadjaji), *ErrorHandler* (greske), *DTDHandler* (DTD), *EntityResolver* (Spoljni entiteti)
    - *DefaultHandler* nasledjuje sve prethodne interfejse praznim metodama, redefinisu se potrebne
- rezultati
    - ocuvani whitespace (sem kod atributa)
        - nema DTD na raspolaganju pa pretpostavlja da svaki element ima mixed content model
    - komentari su ignorisani
        - trebalo bi implementirati *LexicalHandler*
    - prazni elementi: `<item/>` se događajima predstavlja kao `<item></item>`
- *Locator* - objekat koji sadrži podatke o lokaciji na kojoj se desio
    - validan samo u trenucima poziva event-handling metoda
- obrada gresaka
    - *SAXException* može da sadrži i izuzetak koji se desio u event-handleru
    - *SAXParseException* nasledjuje *SAXException* i sadrži informacije o redu u kome je greška događaj
    - tri nivoa gresaka
        - *warning* - npr. element definisan dva puta u DTD-u (jeste greška, ali ne pravi probleme)
        - *error* - npr. dokument nije validan
        - *fatalError* - npr. dokument nije dobro formiran
- CDATA sekcije
    - reference na entitete parser automatski zamenjuje njihovim vrednostima
    - CDATA sekcije parser automatski pretvara u nizove znakova
- parsiranje uz validaciju
    - dokument moze da poseduje svoj DTD ili referencu na spoljasnji DTD
    - nevalidirajući parser ignoriše whitespace tamo gde je to moguće
    - validirajući radi sve to plus validaciju
    - kreiranje parsera - izbor fabrike, *setValidating(boolean)*, *setNamespaceAware(boolean)*
    - moze i pomocu seme
        - `setProperty("http://java.sun.com/xml/jaxp/properties/schemaLanguage", "http://www.w3.org/2001/XMLSchema")`
    - ako povezemu semu programski sema u dokumentu se ignorise

## DOM
- **Document Object Model**
    - W3C standard za objektno-orijentisanu reprezentaciju dokumenata sa hijerarhijskom strukturom - stablo
    - varijante za razlicite jezike i dokumente
    - rezuletat parsiranja je stablo objekata
        - stalno prisutno u memoriji, za ceo dokument
        - redosled obrade elemenata se ne mora poklapati sa redosledom u dokumentu
    - mozemo serijalizovati stablo nazad u XML
    - problem sa zauzecem memorije
        - veliki dokumenti
        - puno dokumenata u isto vreme
- Java specificnosti

## JAXB
- JAXB (Java Architecture for XML Binding) je framework za generisanje Java klasa na osnovu  TD ili XML Schema šema (i obrnuto) i za transformaciju XML dokumenata u graf Java objekata (i obrnuto)
- JAXB parseri rade na višem nivou apstrakcije od SAX, StAX-a i DOM parsera
- JAXB parseri predstavljaju XML dokumente kao Java klase iz odreenog domena
- JAXB se može posmatrati kao jedan nacin (de)serijalizacije stanja Java objekta
- Koriste se za parsiranje transakcionih dokumenata (koji se relativno lako mapiraju na java objekte)
- za parsiranje narativnih dokumenata (koji se tesko mapiraju na java objekte) koriste se drugi parseri
- proces
    - Pomocu binding prevodioca DTD ili XML Schemu prevesti u Java klase (ili obrnuto)
    - Pomocu Java prevodioca prevesti Java klase (u byte kod)
    - Napisati Java program koji transformiše XML dokumente u graf Java objekata (i obrnuto)
- JAXB koristi podrazumevana pravila povezivanja
- Podrazumevana pravila povezivanja mogu se promeniti anotacijama u XML šemi ili Java klasi

## XPath
- definicija
    - jezik za označavanje delova XML dokumenta
    - zasniva se na konceptu navigacije kroz stablo dokumenta
    - ima biblioteku standardnih funkcija
    - W3C standard
- **izrazi**
    - izraz je namenjen za označavanje čvora ili skupa čvorova u dokumentu
    - ovi izrazi liče na izraze za rad sa fajl-sistemom
- XPath sadrži oko 100 ugrađenih funkcija
- **čvorovi**
    - XML dokument se, sa stanovišta XPath-a, posmatra kao stablo
    - vise tipova cvorova
        - element
        - atribut
        - tekst
        - namespace
        - procesna instrukcija
        - komentar
        - dokument (koren)
    - odnosi medju cvorovima - roditelj, dete, brat/sestra, predak, naslednik
    - koncept tekuceg cvora (cvor gde se nalazimo)
- **putanja**
    - sastoji se iz više koraka razdvojenih znakom "/"
    - apsolutna putanja: počinje znakom /
    - relativna putanja: ne počinje znakom /
    - svaki korak se izračunava u odnosu na čvorove u tekućem skupu čvorova (node-set)
- **korak**
    - osa kretanja + test cvor + nula ili vise predikata
    - opsti oblik `osa::test[predikat]`
- **ose**:
    - *ancestor* - svi preci
    - *ancestor-or-self - svi preci ili sam cvor
    - *attribute* - svi atributi (skraceno @)
    - *child* - sva deca (default)
    - *descendant* - svi potomci (skraceno //)
    - *descendant-or-self* - svi potomci ili sam cvor
    - *following* - sve u dokumentu iza zatvarajuceg taga tekuceg cvora
    - *following-sibling* - sva braca posle tekuceg cvora (se moze pisato kao ../)
    - *namespace* - svi namespace cvorovi tekuceg cvora
    - *parent* - roditelj (skraceno ..)
    - *preceding* - sve u dokumentu iza pocetnog taga tekuceg cvora
    - *preceding-sibling* - sva braca pre tekuceg cvora
    - *self* - tekuci cvor (skraceno .)
- **predikati**
    - koriste se za pronalazenje cvora koji zadovoljava dati uslov
    - osnovna primena: filtriranje
    - uvek se pisu unutar uglastih zagrada `[...]`
    - unutar predikata mogu se koristiti funkcije, operatori, @ za atribut
    - `[position() = X]` je skraceno `[X]`
- funkcije i operatori su ugradjeni i ima ih mnogo
- oznacavanje vise putanja odjednom
    - navodjenjem vise *XPath* izraza povezanih operatorom "|"
    - rezultat je unija skupova čvorova dobijenih osnovnim izrazima

## XQuery
- standardni upitni jezik za XML
- W3C standard
- ekvivalent SQL-a za XML dokumente
- **tipovi podataka**
    - svi ugradjeni XML Schema tipovi
    - jos 7 tipova vezanih za tipove cvorova u stablu dokumenta
    - jos 6 tipova specificnih za XQuery
    - svaka XQuery vrednost je sekvenca koja sadrzi 0 ili vise elemenata
        - element sekvence je *singleton* ako sadrzi samo jedan element `(1)=1`
        - sekvenca moze biti prazna `()`
        - ne moze da sadrzi druge sekvence
        - sekvence se poravnavaju `(0, (), (1, 2)) = (0, 1, 2)`
    - svaki *singleton* ima svoj tip izveden iz `item()`
    - tip je apstraktan, ne moze se instancirati
    - pise se sa zagradama da bi se razlikovao od krisnickih tipova istog imena
        - da bude nalik XPath testu cvora
    - tip moze da bude XML cvor ili atomicka vrednost
    - *XML cvorovi* izvedeni iz `node()`
        - *attribute(), comment(), document()...*
    - *atomicke vrednosti* nasledjuju `xdt:anyAtomicType`
        - *xs:boolean, xs:string, xs:data...*
    - sekvenca ima tip koji se sastoji od 
        - imena tipa ili `empty()`
        - (opciono) indikator ponavljanja (*, +, ?)
        - primeri: `item()`, `item()*`, `xsd:integer*`
    - staticki tip (*compile-time*)
    - dinamicki tip (*run-time)
        - tip dobijenog rezultata
        - vrednost rezultata je instanca tog tipa
    - provera tipova moze da se vrsi *compile-time* ili *run-time*
- whitespace i komentari
    - posebni znakovi za whitespace (npr. U+0020 = space)
    - komentar moze da se pojavi bilo gde na mestu whitespace znakova
        - pise se izmedju `(: ... :)`
- **konstante**
    - prazna sekvenca `()`
    - logicke (*xs:boolean*) `true(), false()`
    - stringovi (*xs:string*) `"dokle", "vise"`
    - celi brojevi (*xs:integer*) `42`
    - brojevi u fiksnom zarezu (*xs:decimal*) `42., 4.2, .42`
    - brojevi u pokretnom zarezu (*xs:double*) `42E0, 4.2e+0, 42E-2`
    - drugi tipovi `xs:float("1.25"), xs:ID("X1")`
- **prolog**
    - nije obavezan
    - definiše kontekst za upit (compile-time)
        - namespaces `declare namespace x = "http://www.foo.com"`
        - korisničke funkcije `declare function my:fact($n as xs:integer) as xs:integer {}`
        - importovani šema tipovi
        - importovani moduli
        - promenljive
- rezultat XQuery upita moze biti atomicka vrednost ili XML sadrzaj
- **XML sadrzaj**
    - XQuery se često koristi za generisanje XML dokumenata
        - slično kao u SQL-u (rezultat upita je relacija)
    - XML node constructor `<dokle>vise</dokle>`
    - dinamicko generisanje sarzaja: XQuery izrazi unutar `{ ... }`
        - primer: `<x y="2*2 = {2*2}">Velika istina: 2*2 = {2*2}.</x>`
        - rezultat: `<x y="2*2 = 4">Velika istina: 2*2=4.</x>`
    - navodjenje viticastih zagrada `<add>{{ 1 + 1 = { 1+1 }}}</add>` => `<add>{ 1 + 1 = 2 }</add>`
    - alternativni nacin za knstrukciju elemanata: `element {"ime"} {"sadrzaj"}` => `<ime>sadržaj</ime>`
    - sekvence se poravnavaju pre ugradjivanja u XML
- **operatori**
    - zarez definise sekvencu
        - ima najnizi prioritet pa se sekvence cesto smestaju u zagrade
    - zagrade mogu da grupisu izraze razlicitih tipova
    - logicki operatori `and`, `or`, i `not()`(pise se kao funckija zbog kompatibilnosti sa XPath)
    - *if-then-else* operator
        - else je obavezan
        - `if (true()) then "true" else "false"`
    - aritmeticki
        - binarni: `+, -, *, div, idiv, mod`
        - unarni: `+, -`
    - poredjenje vrednosti za dva singletona: `eq, ne, gt, ge, lt, le`
    - generalno poredjenje - za dve sekvence
        - vraca `true()` ako u obe sekvence postoji bar po jedan element za koji poredjenje po vrednosti vraca `true()`
    - poredjenje cvorova - operisu nad sekvencama cvorova
        - `<<` - "before": vraća true ako je levi čvor ispred/pre desnog u dokumentu
        - `>>` - "after": vraća true ako je levi čvor iza/posle desnog u dokumentu
        - `is` - vraća true ako su čvorovi isti (po identitetu)
        - `isnot` - negacija od is
    - funkcije za poredjenje
        - `compare()`: poredi dve atomicke vrednosti
        - `deep-equal()`: predi cele sekvence, sa dubokim poredjenjem svih elemenata
- **ugradjene funkcije**
    - 110 komada
    - razlikuju se po imenu i listi parametara
    - funkcije nad sekvencama
        - `count()`: dužina sekvence
        - `distinct-values()`: ukloni sve duplikate
        - `empty()`: da li je sekvenca prazna
        - `exists()`: da li sekvenca nije prazna
        - `index-of()`: položaj elementa u sekvenci
        - `insert-before()`: ubaci element u sekvencu
        - `remove()`: ukloni element iz sekvence
        - `reverse()`: obrni redosled sekvence
        - `subsequence()`: izdvoj podsekvencu
        - `unordered()`: naglasi da redosled nije važan
    - aritmeticke funkcije
        - `floor()`
        - `ceiling()`
        - `abs()`
        - `min()`
        - `max()`
        - `avg()`
        - `sum()`
        - `round()`
        - `round-half-to-even()`
<> sintaksni biseri
- **putanje**
    - koristi se neznatno izmenjen [XPath](#xpath)
    - struktura elementa putanje je ista
    - funkcije za navigaciju
        - `collection()`: imenovana sekvenca
        - `doc()`: koren datog XML dokumenta
        - `id()`: element sa datim ID-jem
        - `idref()`: elementi koji pokazuju na dati ID
        - `root()`: koren tekućeg dokumenta
- **promenljive**
    - navode se sa znakom `$` ispred imena
    - ime moze biti nekvalifikovano i kvalifikovano
        - prefiks zamenjuje namespace
    - promenljivama se ne moze menjati vrednost
- **FLWOR izrazi**
    - centralni izraz u XQuery
    - cita se *flower*
    - for, let, where, order by, return
    - namene
        - definisanje promenljivih
        - iteraciju kroz sekvencu
        - filtriranje rezultata
        - sortiranje sekvenci
        - spajanje razlicitih izvora podataka
    - primer
        - `for $i in doc("orders.xml")//Customer`
        - `let $name := concat($i/@FirstName, $i/@LastName)`
        - `where $i/@ZipCode = 91126`
        - `order by $i/@LastName`
        - `return <Customer Name="{$name}">{ $i//Order }</Customer>`
- **kvantifikacija**
    - operatori `some` (postoji) i `every` (za svaki)
    - skraceni FLWOR
    - vracaju logicku vrednost
    - primer: `some $emp in doc("team.xml")//Employee satisfies $emp/@years > 5`
- join
    - *join* funkcionalnosti iz SQL-a se mogu implementirati sablonima
        - dekartov proizvod
        - *inner* *join* (*one-to-one*, *many-to-many*)
        - *outer* *join* (*left*, *right*)
        - self *join*
- **poredjenje sekvenci**
    - egzistencijalno poredjenje
        - uobicajeno poredjenje radi ovo
        - `some()`
    - poredjenje član-po-član
        - `deep-equal()` - ponasa se rekurzivno
        - `shallow-equal()` - ne postoji kao ugradjena funckija (implementacija u slajdovima)
    - univerzalno poređenje - uslov je zadovoljen za svaki element
        - `every()`
- **sortiranje**
    - `order by` - sortira se po datim kljucevima
    - tretiranje prazne sekvence i *NaN*
        - `empty least` - prazna sekvence je manja od svake neprazne; *NaN* je manji od svake ne-*NaN* vrednosti i neprazne sekvence
        - `empty greatest`- prazna sekvenca je veca od svake neprazne; *NaN* je veci od svake *ne-NaN* vrednosti i neprazne sekvence
- grupisanje
    - nema posebnog `group by` operatora
    - rezultujuci XML predstavlja grupisanje
- obrada gresaka
    - statička ili dinamička - zavisno od implementacije
    - `error()` - za programsko izazivanje greske
    - `trace()` - za generisanje poruke o gresci bez prekidanja izvrsavanja

## Vizuelizacija XML Dokumenta
- vizuelizacija XML dokumenta
    - sadrzaj + struktura + prezentacija
    - jedan dokument moze da biti prikazan na vise nacina
        - moze zavisiti od korisnika (npr. autor, urednik, citalac)
        - moze zavisiti od pristupnog uredjaja (npr. web browser, telefon)
    - prikazivanje XML dokumenata oslanja se na neku od postojećih tehnologija (HTML, WDF, PDF, itd.)
    - tehnologije za vizuelizaciju XML dokumenta
        - [CSS](#css) (*Cascading Style Sheets*)
        - XSL (*Extensible Style Sheets*)
            - [XSLT](#xslt) (*XSL Transformations*)
            - [XSL-FO](#xsl-fo) (*XSL Formatting Objects*)
## CSS
- tehnologija za vizuelizaciju pre svega namenjena za HTML
- adaptirana za upotrebu sa XML-om
- HTML je počeo kao jezik za opis strukture dokumenata 
- elementi za formatiranje dodavani su kasnije
- primer: ova dva fragmenta proizvode vizuelno isti rezultat
    - `<h1>Document title</h1>`
    - `<div><font size="7" face="New Times Roman">Document title</font></div>`
    - prva varijana nosi vise semantike nego druga (moze se zakljuciti da je u pitanju naslov najviseg nivoa)
- uveden kako bi se
    - zaustavilo uvođenje novih tagova za formatiranje
    - razdvojila logička struktura dokumenta od njegove prezentacije
    - ustanovio skup atributa koji definišu izgled HTML strane, zajednički za sve web browsere
    - stvorilo sredstvo za prikaz dokumenata na različitim medijima (web browser, papir, PDA, telefoni, govorni uredjaji)
- CSS fajl nije XML dokument, ima sopstvenu sintaksu
- kaskadno - parametri definisani za element A nasledjuju se u svim elementima koje A sadrži
- CSS i XML
    - može se iskoristiti za vizuelizaciju XML dokumenata
    - nije najfleksibilnije rešenje, ali podržan je u svim browserima
    - povezivanje XML dokumenta sa CSS fajlom
        - `<?xml-stylesheet type="text/css" href="fajl.css"?>`
- kada koristiti?
    - kada se web browser koristi za prikaz dokumenata
        - moguće je CSS koristiti i za štampu, ali malo softvera podržava sve CSS funkcije
    - kada je sadržaj dokumenta blizak onome što treba prikazati
        - ukoliko su potrebne transformacije nad podacima u dokumentu CSS se teško može koristiti
- nedostaci
    - nije moguće promeniti redosled elemenata u dokumentu (npr. sortiranje i filtriranje podataka)
    - nisu moguća izračunavanja (proseka, maksimuma, itd.)
    - nije moguće kombinovanje više dokumenata u jedan prikaz

## XSLT
- jezik za opis transformacija XML dokumenata u druge XML
- W3C standard
- za navigaciju koristi XPath izraze
- vizuelizacija - samo jedna od primena
    - kada je rezultat transformacije XHTML
- XSLT je još jedna XML gramatika
- funkcionalnost
    - jedan XML dokument se transformiše u drugi
    - transformacija je opisana XSLT dokumentom
    - transformaciju izvodi XSLT procesor
    - XSLT fajl sadrži definicije **šablona**
        - šablon opisuje transformaciju dela polaznog dokumenta
        - deo polaznog dokumenta se identifikuje XPath izrazom
    - interpretiranje XSLT fajla se svodi na primenu šablona
- `<xsl:stylesheet>` - korenski element svakog XSLT dokumenta
    - atribut `version` - verzija XSLT jezika koja se koristi u fajlu 
    - deklaracija za XSLT namespace, uobičajeni prefiks je xsl
    - sadržaj elementa čine šabloni - `<xsl:template>`
- `<xsl:template>` - definiše šablon
    - atribut `match` sadrži kontekst u kome će se šablon izvršiti
        - kontekst se definiše kao XPath izraz
        - XPath izraz, ako predstavlja relativnu putanju, se izračunava u odnosu na tekući kontekst
        - ako se ne pronađe dati kontekst, šablon se ne izvršava
    - sadržaj elementa se dodaje na kraj rezultujućeg fajla
        - ako se u sadržaju nalaze drugi XSLT elementi, oni se prethodno izračunavaju
- `<xsl:value-of>` - sadržaj datog elementa dodaje u rezultujući dokument
    - atribut `select` predstavlja XPath putanju do željenog elementa
        - ako element ne postoji, ne ubacuje se ništa
        - ako postoji više elemenata za dati XPath, uzima se prvi
    - uvek je prazan
- `<xsl:for-each>` - izdvaja svaki element iz skupa čvorova
    - atribut `select` predstavlja XPath putanju do željenih elemenata
    - sadržaj se dodaje na izlazni fajl za svaki pronađeni element
        - sadržaj se ponovo procesira ako sadrži XSLT elemente
- `<xsl:sort>` - sortira sadržaj tekućeg konteksta prema datom kriterijumu
    - atributi
        - `select` - XPath do čvora čiji sadržaj se koristi kao ključ za sortiranje
        - `data-type` - koji tip podatka se koristi kao ključ (`text`, `number`, `QName`)
        - `order` - opadajući ili rastući redosled (`ascending`, `descending`)
        - `case-order` - prvo velika ili mala slova (`upper-first`, `lower-first`)
        - `lang` - jezik čiji alfabet se koristi za sortiranje (*ISO 639*: *sr*, *en*, *fr*, itd)
    - element je uvek prazan
- `<xsl:if>` - prikazuje svoj sadržaj samo ako je dati uslov ispunjen
    - atribut `test` - uslov koji je potrebno ispuniti
    - primer: `<xsl:if test="price &lt; 10"/>`
- `<xsl:choose>` - izvršava više uzastopnih testova
    - svaki test se opisuje pomoću `<xsl:when>` podelementa
        - atribut test predstavlja sadržaj testa
    - ako nijedan test nije ispunjen, izvršava se `<xsl:otherwise>` podelement
    - poput *switch-case-default*
- `<xsl:apply-templates>` - pokreće ponovnu primenu šablona u okviru tekućeg konteksta
    - ako ima atribut `select` šabloni se primenjuju samo na izabrane podčvorove
- `<xsl:call-template>` - poziva imenovani šablon na datom mestu
    - moze da ima parametre - `<xsl:param name="width"/>`
    - parametri mogu imati podrazumevane vrednosti - `<xsl:param name="bgColor" select="'blue'"/>`
        - moze i unutar elementa kao sadrzaj
    - upotreba parametra `<td width="{$width}" bgcolor="{$bgColor}">`
    - poziv sa parametrom
        - `<xsl:call-template name="addTableCell">`
        - &nbsp;&nbsp;`<xsl:with-param name="width" select="100"/>`
        - `</xsl:call-template>`
- **promenljive**
    - definisanje `<xsl:variable name="x"/>`
        - moze da ima podrazumevanu vrednost
        - moze da sadrzi podelemente poput `<xsl:choose>`
    - upotreba ista kao i kod parametra
    - nije moguce menjati vrednost
    - promenljive su vezane za šablon u kojima su definisane
        - različiti šabloni mogu imati promenljive istog imena
    - globalna promenljiva - dete `<xsl:stylesheet>` elementa
        - vidljiva u svim šablonima koji se nalaze posle njene definicije
         
## XSL-FO
- XML jezik za opis formatiranja straničnih dokumenata
    - radi sa konceptima oblikovanja i raspoređivanja elemenata na stranice
    - originalni XML dokument se mora transformisati u XSL-FO da bi bio prikazan
        - za transformaciju može da se koristi XSLT
    - samo po sebi XSL-FO je XML dokument
    - sadrži opis rasporeda elemenata na stranicama
    - za njegov prikaz potreban je poseban softver za renderovanje
    - najčešće se renderovanje oslanja na neke od rasprostranjenih formata tako što se XSL-FO dokument konvertuje u drugi format (*PDF*, *PostScript*, *PCL(HP)*, *SVG*)
        - XSL-FO *renderer*
- **osnovni pojmovi**
    - *page layout* - raspored stranice
        - fizičke dimenzije, margine, zaglavlje/podnožje, brojevi stranica, itd
    - *block* - površina koju zauzima neki objekat
        - pasus, reč, naslov, slika
    - *inline* - parče teksta koje se prostire u jednom redu
- **Simple page master**
    - XSL-FO može da opiše izgled stranice za stranične medije (štampa) i ne-stranične, kontinualne medije (web)
    - ne-stranični mediji
        - tretiraju se kao mediji sa jednom velikom (dugačkom) stranicom
        - na tu stranicu se gleda kroz prozor, tzv. *viewport*
        - koncepti isecanja (*clipping*), pomeranja prozora (*scrolling*)
    - za stranične medije o ovim detaljima se ne mora voditi puno računa
    - definicija osnovnih parametara
        - `<fo:simple-page-master`
        - &nbsp;&nbsp;`master-name="simple"`
        - &nbsp;&nbsp;`page-height="29.7cm"`
        - &nbsp;&nbsp;`page-width="21cm"`
        - &nbsp;&nbsp;`margin-top="1cm"`
        - &nbsp;&nbsp;`margin-bottom="2cm"`
        - &nbsp;&nbsp;`margin-left="2.5cm"`
        - &nbsp;&nbsp;`margin-right="2.5cm">`
    - atributi iz skupa *common margin properties - block*
        - `margin-top`
        - `margin-bottom`
        - `margin-left`
        - `margin-right`
        - `space-before`
        - `space-after`
        - `start-indent`
        - `end-indent`
    - regioni stranice
        - `<fo:simple-page-master ...>`
        - &nbsp;&nbsp;`<fo:region-body margin-top="1cm"/>`
        - &nbsp;&nbsp;`<fo:region-before extent="3cm"/>`
        - &nbsp;&nbsp;`<fo:region-after extent="1.5cm"/>`
        - &nbsp;&nbsp;`<fo:region-start extent="2cm"/>`
        - &nbsp;&nbsp;`<fo:region-end extent="2cm"/>`
        - `</fo:simple-page-master>`
    - svaki region ima svoje ime
        - ako se ime ne definiše, koristi se podrazumevano ime
    - objekti se dodeljuju regionima preko imena regiona
    - regioni stranice na obodima se dimenzionišu u odnosu na ivicu
    - region `xsl-region-body` (centralni region) ima sopstvene margine
        - one definišu i veličinu i položaj regiona
        - mere se u odnosu na ivicu stranice
        - nema garancije da se ovaj region neće preklapati sa ivičnim regionima (da bi se to izbeglo, njegove margine moraju biti jednake ili veće od dimenzija ivičnih regiona)
    - atribut `writing mode`: način pisanja teksta
        - `lr-tb` (left-to-right, top-to-bottom) ~ evropski jezici
        - `rl-tb` (right-to-left, top-to-bottom) ~ semitski jezici
        - `tb-rl` (top-to-bottom, right-to-left) ~ dalekoistočni jezici
    - atribut `reference-orientation` definiše gde je vrh strane
    - popunjavanje mastera sadržajem
        - sadržaj se nalazi u `<fo:page-content>` elementu
        - sadržaj je grupisan u tokove (*flows*)
        - `<fo:static-content>` - statički sadržaj koji se ponavlja (npr. zaglavlje)
        - `<fo:flow>` - sadržaj koji se ne ponavlja kada se jednom iskoristi
- **Page sequence master**
    - niz različitih formata stranice
        - svaki od tih formata se definiše kao simple page master
    - nizanje različitih mastera na više načina
    - `single-page-master-reference` - dati master će se iskoristiti za tačno jednu stranicu
    - `repeatable-page-master-reference` - dati master će se upotrebiti za onoliko stranica dok se ne potroši tekući *flow* ili za unapred dati maksimalan broj stranica
    - `repeatable-page-master-alternatives` - izbor jednog od mastera zavisno od nekog uslova
        - svaki podelement je referenca na jedan master
        - za svaki podelement je vezan logički uslov (prvi podelement koji ima ispunjen uslov biće iskorišćen za popunu sadržajem)
        - uslovi se izražavaju pomoću tri atributa
            - `page-position`: `first` (prva strana), `last` (poslednja) `rest` (sve ostale), `any` (bilo koja)
            - `odd-or-even`: `odd` (neparna), `even` (parna), `any` (bilo koja)
            - `blank-or-not-blank`: `blank` (prazna), `not-blank` (nije prazna), `any` (bilo koja)
- **Page sequence**
    - predstavlja skup sadržaja obuhvaćenih elementom `<fo:page-sequence>`
    - atributi elementa `<fo:page-sequence>`
        - `master-reference` - ime mastera koji će se primeniti
        - `initial-page-number` - određuje broj prve stranice - `auto`, `auto-odd`, `auto-even`, konkretan broj
        - force-page-count - koliki je ukupan broj stranica - `auto`, `even`, `odd`, `end-on-even`, `end-on-odd`, `no-force`
        - `language` - jezik teksta
        - `country` - država u kojoj se objavljuje dokument
- Prikazani sadržaj čine objekti (*objects*)
    - oni zauzimaju prostor koji se izražava pomoću pojmova
        - površine (*area*)
        - bloka (*block*)
        - reda (*inline*)
- **Area**
    - *area* - pravougaona površina koja ima skup osobina
        - osobine (*traits*) imaju konkretne vrednosti koje odredi XSL-FO renderer
        - atributi (*attributes*) nisu osobine - oni predstavljaju ograničenja u okviru kojih se određuju vrednosti osobina
    - svaka površina se sastoji iz
        - *content rectangle*: deo za sadržaj
        - *padding rectangle*: prostor za odvajanje sadržaja od okvira
        - *border rectangle*: okvir
    - vrste površina
        - *inline area*: parče teksta, ubačena slika (inline površine se nižu jedna za drugom u pravcu `inline-progression-direction`)
        - *block area*: pasus, tabela, lista, ... (block površine se nižu jedna za drugom u pravcu `block-progression-direction`)
        - *glyph area*: jedno slovo
        - *region reference area*: svaki od pet regiona je i površina
    - pozicioniranje površina - određeno atributima
        - `break-before: auto, column, page, odd-page, even-page`
        - `break-after`
        - `keep-with-previous.within-line`: `auto`, `always`, *broj* (mera jačine ograničenja)
        - `keep-with-previous.within-column`
        - `keep-with-previous.within-page`
        - `keep-with-next`
        - `keep-together`
    - dimenzije
        - `inline-progression-dimension`
        - `block-progression-dimension`
        - mogu se eksplicitno postaviti samo za reference areas i slike
    - nizanje blok površina
        - `space-above`: `.minimum`, `.maximum`, `.optimal`
        - `space-below`
        - `precedence`: broj ili force (jačina ograničenja)
        - `conditionality`: `discard`, `retain` (kada nema susedne površine u istoj referentnoj površini)
- **Block**
    - osnovna gradivna jedinica za sadržaj na stranici
        - npr. pasus, tabela, lista, slika
    - blok se sastoji od jedne ili više površina
    - blok sadrži
        - druge blokove
        - jednolinijske fragmente (inline)
        - tekst
    - prelazak na novu stranicu
        - `break-before`: `auto`, `column`, `page`, `even-page`, `odd-page`
        - `break-after`
    - uvlačenje bloka
        - `padding-before`, `padding-after`,` padding-start`, `padding-end`
- *Lista*
    - lista je vrsta bloka
    - struktura: `<fo:list-block>` => `<fo:list-item>` => `<fo:list-item-label>` ^ `<fo:list-item-body>`
- *Tabela*
    - tabela je vrsta bloka
    - struktura: `<fo:table>` => `<fo:table-header>` ^ `<fo:table-body>` => `<fo:table-row>` => `<fo:table-cell>`
    - tabela i potpis `<fo:table-and-caption>` => `<fo:table-caption text-align="center">` ^ `<fo:table>`
- **Inline**
    - jednolinijski fragmenti
        - *bold*, *italic*, itd.
- *Slike*
    - slike su inline elementi
        - ako je potrebno mogu se obuhvatiti u block
    - mogu se ubaciti na dva načina
        - kao eksterni ne-XML sadržaj (npr. JPEG slika) `<fo:external-graphic src="url(images/pic.jpg)">`
        - kao eksterni XML sadržaj (npr. SVG slika) `<fo:instream-foreign-object src="url(images/pic.svg)"`
- *Boja*
    - definisanje boje
        - po imenu: `red`, `blue`, ...
        - RGB model: `#rrggbb` ili `#rgb`
        - po imenu koje je specifično za konkretnu rač. platformu
        - drugi modeli za koje postoji ICC profil `<fo:declarations>` => `<fo:color-profile src="url('./myprofile.icc')" color-profile-name="mycp"/>`
            - `<fo:block color='icc-color(200, 200, 50, mycp, 1.45, 2.22)'>`
- *Fontovi*
    - XSL-FO usvaja OpenType model fonta
    - atributi: `font-family, font-style, font-variant, font-weight, font-stretch, font-size`
    - font mora biti dostupan XSL-FO procesoru
- *Linkovi* - element `<fo:basic-link>`
    
## RDF
- uvodna terminologija
    - podaci (skup simbola koji predstavljaju svojstva objekata, dogaaja ili njihovog okruženja)
    - informacije (podaci organizovani tako da imaju znacenje)
    - znanje (informacije organizovane tako da mogu da se koriste za donošenje odluka)
    - narativni dokumenti (slabo strukturirani)
    - transakcioni dokumenti (jako strukturirani)
    - povezani dokumenti (world wide web)
    - povezani podaci (semantic web, web 3.0)
- **Linked Data**  predstavlja nacin objavljivanja podataka na (semantickom) webu
    - ohrabruje ponovno korišcenje podataka
    - smanjuje redudantnost
    - maksimizira (pravu i potencijalnu) povezanost izmeu podataka
    - omogucava stvaranje "mrežnog efekta" i dodaje vrednost podacima
    - principi
        - Koristiti URI za imena stvari
        - Koristiti HTTP URI da bi stvari mogle da se pronadju
        - Kada neko traži resurs, ponuditi odgovor u RDF formatu
        - U odgovor ukljuciti RDF iskaze koji povezuju traženi resurs sa drugim resursima da bi mogle da se pronau srodne stvari
- **RDF Graph**
    - RDF (Resource Description Framework) je standardni model za razmenu podataka na WWW
    - Proširuje WWW (mrežu dokumenata) tako što koristi URI za imenovanje stvari i njihovih odnosa (i na taj nacin formira mrežu podataka)
    - Ova struktura formira usmeren oznacen graf (ciji su cvorovi resursi i literali, a grane relacije izmeu njih)
    - Graf se može predstaviti kao skup iskaza oblika oblika **`<subjekat> <predikat> <objekat>`**
- **Semantic web stek**
    - XML pruža sintaksu za strukturiranje dokumenata, ali ne namece semanticka ogranicenja na znacenje takvih dokumenata
    - XML Schema je jezik za ogranicavanje strukture XML dokumenata i takoe proširuje XML sa tipovima podataka
    - RDF je model podataka za objekte ("resurse") i odnose izmeu njih, pruža jednostavnu semantiku za ovaj model podataka, i omogucava da se model podataka predstavi u XML sintaksi
    - RDF Schema je recnik za opis klasa i svojstava RDF resursa, sa semantikom poput specijalizacije i generalizacije takvih klasa i svojstava
- motivacija iza RDF-a
    - Problem u pretraživanju iste semantike predstavljene razliciti XML stablima
    - Upit treba da bude nezavisan od nacin na koji je predstavljena semantika
    - Potreba za pretvaranjem svih mogucih predstava semantike u jedan iskaz
- **RDF**
    - Standardizovani nacin za pisanje iskaza
    - Kako god da se ista semantika pojavi u XML dokumentima, predstavljena je na isti nacin RDF iskazima
    - Više XML stabala može da odgovara jednom RDF grafu
    - Resource Description Framework (RDF) je još jedna World Wide Web Consortium (W3C) specifikacija
    - To je graf bazirani model podataka za opisivanje stvari (resursa) i njihovih meusobnih odnosa
    - Omogucava interoperabilnost izmedju aplikacija koje razmenjuju mašinski citljive i razumljive podatke na webu
- **RDF iskaz**
    - **subjekat** (resurs)
    - **predikat** (svojstva)
    - **objekat** (resursa ili literala)
- Resursi
    - Stvari koje se opisuju sa RDF
    - [definicija](#inzenjering-dokumenata)
    - identifikuju se sa IRI(*Internationalized Resource Identifier* - prosirenje URL sa UCS karakterima)
- Svjostva
    - Specificni aspekti, karakteristike, atributi ili odnosi korišceni za opis resursa
    - Vrednost svojstva može biti resurs ili literal
    - Identifikuju se sa IRI
- Literali
    - (tipizirane) konstante
    - XML Schema tipovi podataka
    - ISO kodovi jezika
- URI
    - Za identifikaciju resursa, svojstava i tipova podataka koriste se [URI](#inzenjering-dokumenata)
- konkretne sintakse za RDF
    - *Turtle* (*Terse RDF Triple Language*)
        - konkretna sintaksa za RDF
        - Tekstualna serijalizacija RDF grafa
        - Kompaktna, lako citljiva forma
    - *RDF/XML*
        - Tekstualna XML serijalizacija RDF grafa
        - Obezbeuje maksimalnu interoperabilnost
    - *RDFa* (RDF in attributes)
        - Omogucava ugraivanje RDF iskaza u XML dokumente pomocu standardizovanih atributa
- *GRDDL*
    - *Gleaning Resource Descriptions from Dialects of Languages* (GRDDL) je W3C specifikacija koja olakšava ekstrakciju RDF iskaza iz XML dokumenata
    - Obicno se RDF iskazi u RDFa formatu transformišu u RDF iskaze u RDF/XML formatu korišcenjem XSLT transformacije
- *Linked data*
    - Linked data je skup principa za objavljivanje, pronalaženje i pregledanje podataka u RDF formatu (ti podaci mogu biti distribuirani na više servera)
    - Linked data je korišcenje mreže za povezivanje srodnih podataka koji nisu povezani ili smanjivanje barijere za povezivanje podataka koji su povezani korišcenjem drugih metoda
- Linked Data in the Wild
    - *Schema.org*
        - projekat ciji je cilj stvaranje, održavanje i promovisanje šeme za strukturirane  podatke na internetu
        - Omogucava web stranama da oznace metapodatke u RDFa, JSON-LD i microdata formatima
        - Podržan je od strane vodecih web pretraživaca (Google, Yahoo, Bing, Yandex) koji  prepoznaju metapodatke i na taj nacin dobijaju pristup znacenju web strana
        - Schema.org je deljena kolekcija microdata šema koja ukljucuje hijerarhiju tipova (kao     RDF šema)
    - *DBPedia*
        - crowdsourcing projekat ciji je cilj da ekstahuje strukturiran sadržaj iz informacija  koje sa nalaze u Wikipedia-ji
        - sadržaj se objavljuje u RDF formatu
        - Omoguceno je postavljanje [SPARQL](#sparql) upita nad DBPedia skupom podataka (i  drugim srodnim skupovima podataka)
    - *Open Graph*
        - omogucava integraciju web strana u Social Graph dodavanjem metapodataka u RDFa formatu
        - Podatke u Open Graph formatu, izmeu ostalih, objavljuju IMDb, Microsoft, NHL, Posterous, Rotten Tomatoes, TIME i YelpIt, a koriste Facebook i Google
    - *Knowledge Graph*
        - baza znanja koju koristi Google da bi obogatio web pretragu
        - Tvrdi se da je Knowledge Graph u oktobru 2016 sadržao više od 70 milijardi cinjenica o ljudima, mestima i stvarima
        - Cinjenice su predstavljene kao strukturirane informacije za linkovima ka drugim cinjenicama

## RDFS
- RDFS (RDF Schema) je semanticko proširenje RDF
- Omogucava definisanje domenski specificnih klasa i svojstava
- RDF Schema se zapisuje u RDF formatu
- RDF Schema vs. XML Schema
    - XML Schema deklariše elemente i atribute dokumenata odreenog tipa
    - RDFS definiše klase i svojstva u domenski specificnom semantickom modelu
    - XML Schema zadaje ogranicenja nad strukturom XML dokumenta (može se definisati domenski specificna struktura
    - RDF Schema zadaje "znacenje" RDF iskaz (mogu se definisati domenski specificne klase i svojstva)
- **OWL** (*Web Ontology Language*)
    - može se koristiti za eksplicitno predstavljanje znacenja termina i odnosa izmedju tih termina
    - Pruža formalan opis koncepata, termina, i odnosa u zadatom domenu
    - OWL ima više mogucnosti za izražavanje znacenja i semantike od XML, RDF i RDFS
    - Ova predstava termina i njihovih meusobnih odnosa zove se ontologija
- **Klasa**
    - Klasa u RDFS je slicna klasi u objektno-orijentisanim programskim jezicima (skup slicnih resursa)
    - vrste
        - `rdfs:Resource` - instance ove klase su resursi
        - `rdfs:Class` - instance ove klase su klase
        - `rdfs:Literal` - instance ove klase su vrednosti svojstva koje su tipizirane konstante
        - `rdf:Property` - instance ove klase su svojstva
- **Svojstvo**
    - Svojstva su (bitne) osobine resursa
    - Za razliku od objektno-orijentisanih programskih jezika, svojstva su "ravnopravna" sa klasama (takodje su resursi i takodje se mogu nasleivati)
    - atributi
        - `rdf:type` - tip resursa (klasa ciji je resurs instanca)
        - `rdfs:subClassOf` - klasa je specijalizacija klase
        - `rdfs:subPropertyOf` - svojstvo je specijalizacija svojstva
    - ogranicenja (u vidu atributa)
        - `rdfs:domain` - domen svojstva
        - `rdfs:range` - kodomen svojstva
- **Anotacije**
    - `rdfs:comment` - opis resursa (human-readable)
    - `rdfs:label` - ime resursa (human-readable)
    - `rdfs:seeAlso` - resurs koji pruža dodatne informacije o resursu
    - `rdfs:isDefinedBy` - resurs koji definiše resurs

## SPARQL
- upitni jezik za postavljanje upita nad podacima u RDF formatu
- SPARQL je protokol za postavljanje upita nad udaljenim RDF skladištima preko HTTP protokola
- SPARQL (kao upitni jezik) omogucava:
    - Ekstrakciju podataka iz strukturiranih i polustrukturiranih izvora
    - Transformaciju podataka u RDF formatu iz jednog recnika u drugi
    - Izvršavanje složenih join operacija u jednom jednostavnom upitu
- **Upiti**
    - izvršavaju se nad RDF grafovima
    - nad raznorodnim izvorima podataka
        - podaci izvorno skladišteni u RDF formatu
        - podaci skladišteni u drugom formatu (XML, HTML, RDB) koje middleware transformiše u RDF format
    - vrste
        - `SELECT` - vraca promenljive u tabelarnom obliku
        - `CONSTRUCT` - vraca RDF graf konstruisan na osnovu promenljivih
        - `ASK` - vraca logicku vrednost koja oznacava da li ekvivalentan `SELECT` upit vraca rezultat
        - `DESCRIBE` - vraca RDF graf koji opisuje resurs
    - struktura
        - Deklaracija prefiksa (skracivanje URI)
        - Definicija izvora podataka (RDF grafova nad kojima ce se izvršiti upit)
        - Klauzula rezultata (specifikacija podataka koje ce upit vratiti)
        - Obrazac grafa (specifikacija restrikcija nad podacima)
        - Modifikatori upita (isecanje, sortiranje, grupisanje i drugo modifikovanje rezultata)
- **Obrazac grafa**
    - SPARQL pomenljive pocinju sa ? i mogu da se poklapaju sa bilo kojim cvorom (resursom ili literalom) ili vezom u RDF grafu
    - Obrasci trojki su trojke u kojima je bilo koji element (subjekat, predikat ili objekat) zamenjen sa promenljivom
    - Obrazac grafa je skup obrazaca trojki (koji mogu biti filtrirani logickim izrazima) i modifikovani `OPTIONAL` i `UNION` kljucnim recima
- `FILTER` primenjuje operator/funkciju na rezultat
    - tabela operatora i funkcija na slajdovima
- **FROM NAMED**
    - SPARQL upiti se izvršavaju nad RDF skupovima podataka koji se sastoje iz RDF grafova
    - RDF skupovi podataka sastoje se iz podrazumevanog grafa i nula ili više imenovanih grafova (identifikovanih sa URI)
    - Imenovani grafovi mogu se specificirati sa `FROM NAMED` klauzulom
    - `GRAPH` klauzula omogucava da se delovi upita poklapaju sa imenovanim grafovima u RDF skupu podataka (sve izvan `GRAPH` klauzule se poklapa sa podrazumevanim grafom)
- *Rezultati* se mogu vartiti u razlicitim formatima
    - XML (SPARQL Query Results XML Format)
        - Serijalizuje rezultat SPARQL `SELECT` i `ASK` upita u XML
        - Rezultat `SELECT` upita je tabela (slicna HTML table elementu)
        - Rezultat ASK upita je logicka vrednost
    - JSON (SPARQL 1.1 Query Results JSON Format)
        - Serijalizuje rezultat SPARQL `SELECT` i `ASK` upita u JSON
        - Rezultat `SELECT` upita je tabela serijalizovana u niz (elementi niza su vrste tabele)
        - Rezultat `ASK` upita je logicka vrednost
    - CSV/TSV (SPARQL 1.1 Query Results CSV and TSV Formats)
        - Rezultat `SELECT` upita može se serijalizovati i u CSV i TSV format
        - Pogodno za uvoz podataka u Excel, RDBMS, itd.
    - RDF (može se serijalizovati u više formata)
    - HTML (kada se sa SPARQL upitima radi u interaktivnom modu)
- `CONSTRUCT` upit
    - alternativa `SELECT` upitu koja vraca RDF graf umesto tabele
    - RDF graf se konstruiše tako što se uzimaju rezultati ekvivalentnog `SELECT` upita i sa njima zamenjuju vrednosti promenljivih u obrascima u `CONSTRUCT` klauzuli
    - U RDF grafu se ne konstruišu trojke za obrasce u kojima se nalaze nevezane promenljive
- `ASK` upit
    - vraca logicku vrednost u zavisnosti od toga da li se obrazac poklapa sa nekim (bilo kojim) skupom podataka
    - Kao i kod `SELECT` upita, rezultati su podrazumevano kodirani u XML formatu
- `DESCRIBE` upit
    - upit vraca RDF graf koji opisuje zadati resurs
    - Nisu interoperabilni zato što razliciti serveri mogu da ih interpretiraju na razlicite nacine
- *RDF skladista (triplestores)*
    - Skladište podatke izvorno u RDF obliku (kao RDF graf ili skup RDF trojki/iskaza)
    - Omogucavaju izvršavanje SPARQL upita nad podacima koje skladište
    - Indeksiranjem su optimizovani za izvršavanje upita nad grafovima
- *SPARQL krajnje tacke (endpoints)*
    - prima zahteve i vraca odgovore preko HTTP protokola (SPARQL protokol ili RESTful)
        - Genericke krajnje tacke omogucavaju izvršavanje upita nad bilo kojim RDF skupom podataka dostupnim na mreži
        - Specificne krajnje tacke su podešene za izvršavanje upita nad tacno odreenim skupom podataka
    - Podaci mogu bili skladišteni u RDF skladištima, ali i u drugim vrstama skladišta (RDBMS, XML, itd.) kojima se pristupa preko middleware
- *MarkLogic*
    - Komercijalna enterprise NoSQL baza podataka
    - Skladištenje i pretraživanje podataka u XML, RDF i JSON formatu
    - Podrška za ACID transakcije
    - Distribuirana arhitektura koja lako skalira
- *Jena*
    - Java framework otvorenog koda za skladištenje, izvršavanje upita i rezonovanje sa podacima u RDF formatu
    - Serijalizacija i deserijalizacija RDF u RDF/XML, N3, N-Triples, itd
    - Skladištenje podataka u memoriji i na disku
    - Izvršavanje SPARQL upita
    - Podrška za OWL (Web Ontology Language) korišcenjem internih rezonera i Pellet rezonera
- *RDF4J (Sesame)*
    - Sesame je framework otvorenog koda za skladištenje RDF podataka i izvršavanje upita nad njima
    - Sadrži implemantaciju RDF skladišta u memoriji i na disku
    - Sesame RDF Input/Output paket sadrži Java API za serijalizaciju i deserijalizaciju RDF podataka u/iz popularnih formata
    - Podrška za SPARQL and SeRQL

## Poslovni procesi
- Poslovni proces je skup aktivnosti koje jedan ili više ulaza transformišu u jedan ili više izlaza radi ostvarivanja planiranog cilja
- Ulazi i izlazi mogu biti informacije (dokumenti)
- svojstva
    - Poslovni procesi mogu se izvršavati od nekoliko sekundi, preko nekoliko meseci, do nekoliko godina (radni tokovi su dugotrajne transakcije)
    - Poslovni procesi mogu se sastojati od drugih poslovnih procesa (radni tokovi su ugnježdene transakcije)
    - Redosled aktivnosti u poslovnom procesu može, a ne mora biti definisan (mogu se izvršavati konkurentno)
    - Nivo automatizacije poslovnih procesa varira (mogu se izvršavati automatski, poluautomatski ili rucno)
- primeri: Izrada diplomskog rada, Kupovina robe, Obavljanje lekarskog pregleda, Dobijanje graevinske dozvole, Donošenje skupštinske odluke
- **aktivnosti**
    - atomicki koraci poslovnog procesa na posmatranom nivou apstrakcije
    - primeri: Odbrana diplomskog rada, Placanje, Zakazivanje lekarskog pregleda, Podnošenje zahteva za izdavanje graevinske dozvole, Glasanje u pojedinostima
- [dokumenti](#inzenjering-dokumenata)
- **Agenti i uloge**
    - Agent je osoba potrebna za izvšavanje aktivnosti
    - Uloga je sposobnost agenta za izvršavanje odredjene aktivnosti
    - Jedan agent može imati više uloga, može postojati hijerarhija uloga
    - primeri: Student, Prodavac, Lekar, Preduzetnik, Odbornik
- Sistemi za upravljanje radnim tokovima / poslovnim procesima
    - omogucavaju definisanje, izvršavanje i nadgledanje izvršavanja radnih tokova
    - Nazivaju se i sistemi za upravljanje radnim tokovima bazirani na dokumentima
- **modelovanje poslovnih procesa**
    - sta?
        - Analiza poslovnih procesa
        - Sinteza poslovnih procesa
    - zasto?
        - Automatizacija poslovnih procesa
        - Poboljšanje poslovnih procesa
        - Reinženjering poslovnih procesa
    - kako?
        - (UML) dijagram aktivnosti
        - Business Process Modelling Notation (BPMN) dijagram
- **model poslovnih procesa**
    - Sastoji se od skupa aktivnosti i ogranicenja nad tim skupom (predstavlja aktivnosti i njihove meusobne odnose)
    - Može se koristiti za komunikaciju izmeu ucesnika u razvoju informacionih sistema ili za konfiguraciju sistema za upravljanje radnim tokovima / poslovnim procesima
    - Graficka reprezentacija poslovnih procesa fokusira se na strukturu procesa i interakciju izmeu agenata (umesto tehnickih aspekata)
- *UML dijagram aktivnosti*
    - UML dijagrami aktivnosti mogu se koristiti za modelovanje poslovnih procesa / radnih tokova
    - Prikazuju niz aktivnosti, od pocetne tacke poslovnog procesa do krajnje tacke poslovnog procesa, detaljno opisujuci tok kontrole
    - UML dijagrami aktivnosti opisuju sekvencijalni ili konkurentni tok aktivnosti u sistemu
    - elementi
        - *Start* - Predstavlja pocetak poslovnog procesa u dijagramu aktivnosti
        - *Activity* - Glavni element dijagrama aktivnosti koji predstavlja aktivnosti koje cine modelovani poslovni proces (moze biti kompozitna)
        - *Control Flow* - Oznacava redosled aktivnosti u poslovnom procesu (tok aktivnosti)
        - *Object Flow* - Predstavlja objekat (u našem slucaju dokument) koji se prosledjuje od jedne do druge aktivnosti
        - *Fork* - Deli jedan tok u dva konkurentna toka
        - *Join* - Spaja dva konkurentna toka u jedan tok
        - *Decision* - Predstavlja (uslovno) grananje ili spajanje tokova
        - *Merge* 
        - *Option Loop* - Predstavlja repetitivne sekvence
        - *Note* - Omogucava predstavljanje informacije koje nije moguce predstaviti ostalim
elementima dijagrama aktivnosti
        - *Send Signal* - Predstavlja slanje signala primajucoj akciji
        - *Receive Signal* - Predstavlja primanje signala (posle primanja signala izvršava se tok koji izlazi iz ove akcije)
        - *Flow Final* - Predstavlja kraj jednog toka u poslovnom procesu (poslovni proces može imati više konkurentih tokova)
        - *End* - Predstavlja kraj poslovnog procesa u dijagramu aktivnosti

## SOA - Service Oriented Architecture
- **softverska arthitektura**
    - osnovna organizacija sistema
        - otelotvorena u komponentama
        - njihovim vezama sa drugim komponentama i okruženjem
        - i principima koji definišu njihov dizajn i evoluciju
    - skup osnovnih odluka o softverskom rešenju koje ispunjava zadate parametre kvaliteta
    - obuhvata osnovne komponente, njihove osnovne atribute i način saradnje
    - izražava se na različitim nivoima apstrakcije
        - zavisno od veličine projekta
    - opisuje se iz više perspektiva
- rana definicija arhitekture
    - skup najranijih odluka u dizajnu
        - najteže za kasnije izmene
        - najvažnije da se dobro odrede
    - prvi rezultat dizajna gde se vodi računa o parametrima kvaliteta
    - arhitektura služi i kao skup smernica za projekat
        - struktura tima
        - organizacija dokumentacije
        - raspodela radnih zadataka
        - raspoređivanje, planiranje, budžet
        - testiranje, integracija
    - ustanovljava mehanizme za komunikaciju i koordinaciju komponenti
- **servis**
    - u ekonomiji: **usluga** - nematerijalni ekvivalent dobra
        - ekonomska aktivnost koja ne rezultuje posedovanjem materijalnog dobra
        - proces koji kreira korist stvarajući promenu korisnika, promenu njihovih dobara ili promenu njihovih neopipljivih vrednosti
    - u računarstvu: više značenja
        - Windows servis: RPC Locator, Print Spooler, Event Log, DHCP Client
        - softverski servis: bezbednosni servis, logovanje, ...
        - poslovna funkcija: glavna knjiga, upravljanje zalihama
- SOA nije
    - neka konkretna tehnologija
    - novo ime za EAI (*Enterprise application integration*)
        - alati za povezivanje različitih aplikacija u okviru organizacije
        - vendor lock-in: vezivanje za jednog proizvođača softvera
    - novi način da se radi RPC (*Remote procedure call*)
    - novo rešenje za software reuse
- SOA ≠ web servisi
    - web servisi ~ procedure/metode dostupne putem HTTP-a (loše odabrano ime za ovetehnologije)
    - kada se govori o SOA često se misli na WS* standarde 
    - "gomila web servisa" ≠ SOA ("just a bunch of web services" (JBOWS))
- SOA ≠ EAI
    - alati za povezivanje različitih aplikacija u okviru organizacije
        - obezbeđuje konzistentne podatke u različitim aplikacijama
    - vendor lock-in: vezivanje za jednog proizvođača softvera
    - mane EAI:
        - EAI je data-centric, a ne process-centric
        - ne može da isprati promene u poslovnim procesima
        - ne bavi se poslovnim procesima
        - vrlo složena tehnička rešenja, retki/skupi kadrovi
    - web servisi se mogu koristiti kao sredstvo za EAI
        - izbegava se vendor lock-in
- easy reuse
    - OO iskustvo: reuse je komplikovaniji što su komponente koje pokušavamo da iskoristimo veće
    - servis implementira neku poslovnu funkciju/uslugu
        - može se iskoristiti (use)
        - može se integrisati u veći proces
        - teško se može ponovo iskoristiti (reuse) za implementaciju drugog servisa
    - fokus je na agilnosti
        - mogućnost brze promene/adaptacije
        - a ne na korišćenju originalnog servisa izvan originalnog konteksta
- SOA ne zahteva pristup "sve ili ništa"
    - teza mnogih proizvođača: usvojiti SOA i odbaciti sve staro
    - prava strategija je upravo suprotna: postepeno usvajanje
        - funkcionisanje organizacije ne može da čeka na novu implementaciju
        - funkcionisanje organizacije mora biti što manje ometano prilikom tranzicije
            - dodavanje SOA *shell-a* oko stare implementacije
            - kasnija zamena stare implementacije novom
- SOA neće učiniti integraciju jednostavnom
    - pažnja je često usmerena samo na interfejs
        - jednostavno je povezati servise u komunikaciji (koristimo XML, WS*)
    - nije jednostavno dizajnirati interfejs servisa tako da bude upotrebljiv u različitim kontekstima (SOA ovo ne rešava)
- iz poslovne perspektive: **S**ervice **O**riented Architecture
    - analiza poslovanja → identifikacija poslovnih procesa
    - implementacija servisa
    - komunikacija sa servisom putem poruka
    - koreografija
        - kako se obratiti servisu, kako ga iskoristiti u nekom kontekstu
    - orkestracija
        - kako implementirati servis pomoću pozivanja drugih servisa
    - poenta je obezbediti agilnost u poslovanju
        - softverska podrška mora biti lako izmenljiva
- iz tehničke perspektive: Service Oriented **A**rchitecture
    - softverska arhitektura bazirana na komponentama koje su
        - slabo spregnute (loosely coupled)
        - interoperabilne
        - jednostavne za kombinovanje
    - komponente/servisi imaju jasno definisane interfejse
    - sistemi se formiraju od komponenti/servisa koje su
        - krupne (coarse grained)
        - autonomne
        - dostupne na adresama (endpoints) koje se mogu otkriti
        - komuniciraju putem poruka
- **Koncepti**
    - **Servis** - sredstvo koje ispunjava neki zahtev
        - jasna i jedinstvena funkcija
        - visoka kohezija
        - "krupno parče" poslovne logike
        - autonoman rad, samodovoljan, donekle i samoisceljujući
    - **Ugovor** (*contract*) - skup poruka koje poznaje servis
        - jednostrani: servis sam definiše svoje poruke
        - dvo/višestrani: poruke se definišu za dva ili više servisa u kombinaciji
        - analogno OO pojmu interfejsa
    - **Endpoint** - adresa (URI) na kojoj je servis dostupan
        - različiti ugovori jednog servisa mogu biti na različitim adresama
    - **Poruka** - jedinica komunikacije sa servisom
        - razni tehnološki oblici: HTTP GET, SOAP, SMTP,
        - razlikuje se od RPC: ima header (za infrastrukturne servise) i body
    - **Politika** - uslovi kada je servis dostupan
        - specificira dinamičke osobine servisa (kada i za koga je dostupan)
        - može da se ažurira run-time
        - odvojena od poslovne logike
        - ono što razlikuje servis od OO objekata/komponenti
    - **Korisnik servisa** bilo koji softver koji komunicira sa servisom putem razmene poruka
        - klijent aplikacije
        - drugi servisi
- Interface
    - četiri koncepta se bave interfejsom (poruka, ugovor, endpoint, policy)
        - u OO paradigmi samo jedan
    - fokus na interfejs omogućava kreiranje komponenti koje su
        - slabo povezane
        - jednostavne za kombinovanje
    - isti koncepti koriste se u oba viđenja SOA
        - jednostavnija konvergencija poslovne i tehničke perspektive
- *Distribuirano okruzenje*
    - pogrešne pretpostavke o distribuiranom okruženju
        - mreža je homogena
        - mreža je pouzdana
        - mreža je bezbedna
        - kašnjenje je nula
        - propusni opseg je neograničen
        - prenos ne košta
        - topologija se ne menja
        - postoji jedan administrator
    - poruke se šalju ponovo
    - poruke mogu da stignu više puta
    - važna karakteristika poruka: idempotentnost
        - proizvodi isti rezultat i kad se primeni više puta
        - primer ne-idempotentne poruke - `podigni 1000€ sa računa`
        - primer idempotentne poruke - `ako nisam ranije podigao 1000€ uz oznaku #XYZ, podigni 1000€ i označi to sa #XYZ`
    - modeli komunikacije
        - zahtev/odgovor (klasična klijent/server komunikacija)
        - zahtev/reakcija (odgovor na zahtev se obrađuje dugo, šalje asinhrono)
- Tehnoloska podrska
    - web servisi: SOAP, WSDL, UDDI
    - dodatni WS-* standardi
        - WS-Interoperability
        - WS-Security
        - WS-ReliableMessaging
        - WS-Reliability
        - WS-Transactions
        - WS-Coordination
        - WS-Orchestration, WS-Choreography, WS-Addressing, WS-Policy...
- **Sabloni**
    - patterns
        - struktura servisa
        - performanse, skalabilnost i dostupnost
        - bezbednost i upravljivost
        - interakcija servisa
        - interakcija sa korisnikom
        - kompozicija servisa
    - anti-patterns
        - struktura servisa
        - performanse

## Web servisi i SOAP protokol
- pojam **web servisa**
    - web servisi predstavljaju programe koji su dostupni putem javno objavljenih interfejsa i putem standardnih komunikacionih protokola
    - ono što se danas najčešće podrazumeva pod web servisima su programi
        - dostupni putem SOAP protokola
        - sa interfejsom za pristup opisanim pomoću WSDL jezika
        - potencijalno) registrovani u UDDI servisu.
- Web servisi i tehnologije distribuiranih sistema
    - *DCOM* - tehnologija distribuiranih objekata specifična za Windows platformu
    - *Java RMI* - tehnologija distribuiranih objekata specifična za Java platformu
    - *CORBA* - tehnologija distribuiranih objekata nezavisna od platforme i programskog jezika
    - *EJB* - tehnologija distribuiranih objekata koja se oslanja na RMI i CORBA
    - *.NET* - tehnologija distribuiranih objekata specifična za Windows platformu
- čemu još jedna tehnologija?
    - svi elementi arhitekture, uključujući i komunikacioni protokol, su zasnovani na XML-u
        - jednostavnija implementacija nego kod binarnih formata
        - veća interoperabilnost među različitim implementacijama
    - upotreba standardnih Internet transportnih mehanizama
        - firewall-friendly
        - globalna dostupnost web servisa
    - fokus je na interoperabilnosti
    - konverzija podataka u/iz XML formata
        - nisu pogodni za sisteme gde su performanse komunikacije od posebnog značaja
    - homogeni sistemi u celosti implementirani na jednoj razvojnoj platformi
        - nepotrebno komplikovanje implementacije sistema
- Dve paradigme distribuiranih sistema
    - RPC = Remote Procedure Calls - podražavaju sintaksu i semantiku pozivanja funkcija/metoda
        - jednostavno za učenje
        - efikasno za kodiranje
        - tipično za sinhronu komunikaciju
    - slanje poruka (message passing, document-style) - komunikacija između sistema pomoću slanja (strukturiranih) poruka
        - veza između sistema je data formatima poruka
        - bolje razdvajanje delova sistema (loosely coupled)
        - veća međusobna nezavisnost pojedinih delova
        - tipično za asinhronu komunikaciju
- **API-level specifikacije**
    - predstavljaju definicije klasa, interfejsa, metoda, itd. koje su načinjene za date potrebe
    - primeri:
        - JDBC – pristup relacionim bazama podataka
        - JDO – pristup objektnim bazama podataka
        - JNDI – pristup direktorijumskim sevisima
    - omogućavaju pojednostavljenu zamenu programskih modula koji su apstrahovani datim API-jem
        - zamena baze podataka => zamena JDBC drajvera, neznatna promena programa
        - zamena direktorijumskog servera => zamena JNDI provajdera, neznatna promena programa
        - uspešna komunikacija JDBC drajvera jednog proizvođača sa bazom podataka drugog nije garantovana
    - konkretna implementacija predstavlja programsku biblioteku koja podržava API
        - preuzima se od nekog proizvođača
        - pišemo je sami
- **wire-level specifikacije**
    - predstavljaju definicije formata poruka koji se razmenjuju između učesnika u komunikaciji i postupka razmene poruka
    - primeri:
        - HTTP
        - SMTP (*Simple mail transfer protocol*)
    - wire-level specifikacije omogućavaju komunikaciju heterogenih delova sistema
        - zamena jednog web servera drugim => klijenti će i dalje moći da komuniciraju
    - konkretna implementacija podrazumeva biblioteku koja implementira dati protokol
    - način pristupa biblioteci nije unapred propisan
    - programski kod zavisi od upotrebljene biblioteke
- API-level specifikacija za pristup wire-level protokolima
    - najbolje rešenje u smislu prenosivosti i interoperabilnosti programa
    - komplikovano za upotrebu sa stanovišta programera (više isprepletanih standarda)
    - primeri:
        - JAXM – Java API for XML Messaging
        - JAXB – Java API for XML Binding
        - JAX-RPC – Java API for XML-based RPC
        - JAXR – Java API for XML Registries
- **SOAP** - *Simple Object Access Protocol*
    - protokol za komunikaciju sa web servisima
    - definiše format poruka koje razmenjuju učesnici
    - oslanja se na neki transportni mehanizam za prenos SOAP poruka
        - najčešće HTTP, ali nije obavezno, može i npr. SMTP
    - SOAP verzija 1.2 je standard koga propisuje W3C
    - u komunikaciji između krajnjih učesnika (endpoints) može biti posrednika (SOAP proxies)
- **HTTP binding**
    - upotreba HTTP protokola za prenos SOAP poruka
    - za slanje zahteva koristi se HTTP POST komanda
- struktura poruke
    - XML dokument sa korenskim elementom Envelope
        - opcionim podelementom Header
        - obaveznim podelementom Body sa opcionim podelementom Fault
- **Envelope**
    - obuhvata celu SOAP poruk
    - definisan je u prostoru imena `http://www.w3.org/2001/12/soap-envelope`
    - atribut `encodingStyle` definiše namespace sa tipovima podataka koji se koriste u dokumentu
        - odnosi se na element u kome je definisan i sve njegove podelemente
        - formalno nema podrazumevanu vrednost
        - u praksi se koristi `http://www.w3.org/2001/12/soap-encoding`
        - zapravo definiše način serijalizacije podataka iz aplikacije u XML
- **Header**
    - sadrži podatke koji opisuju kontekst u kome se šalje poruka ili uputstva za posrednike u komunikaciji između krajnjih učesnika
    - ovi podaci ne predstavljaju samu poruku, već pomoćne podatke koji utiču na način obrade poruke
    - na primer:
        - podaci za autentifikaciju
        - podaci za praćenje sesije
        - podaci za upravljanje transakcijama
    - Header pripada istom namespace-u kao i Envelope
    - svi Header podelementi moraju biti kvalifikovani u odgovarajući namespace
    - atribut `soap:actor` označava onaj čvor u komunikaciji (proxy ili endpoint) za koga je namenjen dati podatak u zaglavlju
    - svaki SOAP procesor može da dodaje elemente u zaglavlje na putu poruke od pošiljaoca do konačnog primaoca
    - svaki SOAP procesor je dužan da ukloni one elemente iz zaglavlja koji su namenjeni njemu
        - ono što je namenjeno njemu može ponovo dodati u zaglavlje prilikom daljeg slanja
    - `soap:Header@mustUnderstand` - Koncept opcionih i obaveznih elemenata u zaglavlju
        - u smislu da je primalac dužan da razume i na pravilan način upotrebi dati podatak u zaglavlju
        - Efekat: primalac poruke ne može da obradi poruku jer ne ume da interpretira obavezni podatak u zaglavlju
        - ako je element zaglavlja obavezan, atribut `soap:mustUnderstand` ima vrednost 1
- **Body**
    - sadrži konkretan SOAP zahtev ili odgovor
    - pripada istom namespace-u kao i Envelope i Header
    - koristi se kod svih vrsta web servisa (RPC-style, document-style)
- **Fault**
    - opcioni podelement elementa `Body`
    - sadrži podatke o nastalim greškama namenjene klijentu
    - ima četiri podelementa:
        - faultcode
        - faultstring
        - faultactor
        - detail
- `soap:Fault/faultcode` - indikacija greške namenjena programskoj obradi
    - obavezan
    - moguće vrednosti:
        - `VersionMismatch` - element Envelope pripada pogrešnom namespace-u
        - `MustUnderstand` - neposredni Header podelement, sa atributom `mustUnderstand="1"`, nije interpretiran
        - `Client` - poruka sa zahtevom je nepravilno formirana ili sadrži neispravne podatke. Klijent ne bi trebalo da istu poruku ponovo šalje
        - `Server` - poruka nije mogla biti obrađena zbog problema u radu servera; sama poruka ima ispravan format i sadržaj. Klijent može pokušati sa istom porukom kasnije
    - Predefinisani kodovi greške su proširivi, na primer
        - `Server.DatabaseFailure`
        - `Server.DatabaseFailure.MaxUsersConnected`
- `soap:Fault/faultstring`
    - tekstualni opis greške namenjen čoveku (human-readable)
    - obavezan
- `soap:Fault/faultactor`
    - indikacija koji čvor u komunikaciji je uzrok greške (u paru sa `actor` atributom)
    - ako se ne navede, podrazumeva se da je greška nastala na krajnjem čvoru komunikacije (*endpoint*)
- `soap:Fault/detail`
    - opisuje greške koje su posledica neispravnog sadržaja Body elementa u zahtevu
    - ako sadržaj (ili nedostatak sadržaja) u Body elementu sprečavaju obradu poruke, element `detail` sadrži opis greške
    - ako greška nije nastala usled sadržaja Body elementa u zahtevu, element `detail` se ne sme pojaviti
- dve mogucnosti reprezentacije podataka
    - SOAP encoding: mapiranje podataka iz Jave/C++/... na XML u skladu sa SOAP specifikacijom
    - XML Schema: podaci koji se prenose definisani su XML šemom
- *SOAP encoding*
    - podaci koji se nalaze u okviru Body elementa nastali su serijalizacijom podataka iz aplikacije u XML format u skladu sa nekom XML šemom
    - SOAP ne definiše podrazumevanu šemu
    - može se koristiti više različitih šema u jednoj SOAP poruci
    - izbor aktivne šeme određuje se atributom `encodingStyle`
    - jedina unapred definisana šema pripada namespace-u `http://www.w3.org/2001/12/soap-encoding`
        - sadrži sve predefinisane tipove podataka iz specifikacije *XML Schema Part 2: Datatypes*
        - npr. `xsd:string`,` xsd:int`,` xsd:boolean`, itd
    - svi podaci u telu poruke predstavljeni su kao sadržaj elementa
- tipovi podataka
    - **jednostavni** (*simple*)
        - atomičke vrednosti
        - ne sadrži podelemente niti atribute
    - **agregirani** (*compound*)
        - sadrži više atomičkih podataka organizovanih u neku strukturu
        - npr. niz
    - **navođenje tipa podatka**
        - atributom xsi:type
        - elementima niza je tip definisan za ceo niz
        - tipovi su predefinisani tipovi ili novi tipovi definisani pomoću XML Schema jezika
    - **reference**
        - element na koji ukazuje referenca mora sadržati atribut `id` tipa `ID`
        - elementi koji predstavljaju referencu su prazni i imaju atribut `href` čiji sadržaj je identifikator
    - stringovi, nabrojivi tipovi, binarni podaci, null vrednosti, nizovi
    - `soapenc:root` - specijalni atribut koji označava
        - početak liste
        - koren stabla
        - itd.
- *polimorfizam*
    - recimo da je element `quantity` u nekoj šemi definisan kao tip `xsd:int`
    - *polimorfizam* predstavlja dinamičku promenu tipa u telu poruke
    - prmer `<quantity xsi:type="xsd:float">37</quantity>`
- Web servisi RPC tipa
    - pozivanje metoda udaljenog objekta
        - SOAP zahtev = poziv metode
        - SOAP odgovor = rezultat metode
    - za poziv je potrebno
        - identifikator objekta kome se upućuje poruka (ugradjuje se u POST komandu HTTP zahteva)
        - naziv metode - određen podelementom Body elementa, servis mora da ga prepozna
        - parametri metode - dobijeni serijalizacijom podataka iz aplikacije
        - podaci za SOAP zaglavlje - strukturiran prema datoj šemi
- Document-style web servisi
    - servisu se šalje XML dokument
    - metoda servisa koja će obraditi dokument se ipak mora nekako navesti
        - naziv prvog Body podelementa mora naznačavati metodu koja će se pozvati za obradu datog dokumenta
        - namespace tog elementa identifikuje servis koji će obraditi zahtev
    - komunikacija nije obavezno po modelu zahtev/odgovor


## WSDL
- WSDL = *Web Services Description Language*
    - XML gramatika za opisivanje web servisa kao skupa krajnjih pristupnih tačaka (access endpoints) koji mogu da razmenjuju poruke na RPC - ili document-style način 
        - access endpoint = URL na koji se šalje zahtev
    - WSDL ~ CORBA IDL
        - oba standarda su namenjena definisanju interfejsa i tipova podataka za servise dostupne sa udaljenih klijenata
    - WSDL obezbeđuje proširivost koju CORBA IDL nema
        - opisivanje krajnjih pristupnih tačaka (endpoints) i poruka bez obzira na korišćeni mrežni protokol ili format poruka za razmenu
        - tretman poruka kao apstraktnih opisa podataka koji se razmenjuju
        - tretman tipova portova kao apstraktnih kolekcija operacija web servisa
- **koncepti**
    - WSDL fajl opisuje
        - šta servis radi
        - kako pozvati njegove operacije
        - gde ga pronaći
    - na osnovu WSDL specifikacije servisa moguće je generisati
        - implementaciju servisa (delimičnu – tela metoda ćemo morati sami da napišemo!)
        - klijentske klase za pristup servisu
    - na osnovu datih interfejsa u implementaciji servisa moguće je generisati
        - WSDL fajl koji opisuje dati servis
    - koka/jaje problem
        - da li prvo napisati WSDL specifikaciju servisa pa onda pisati implementaciju servisa (kada očekujemo da će međusobno komunicirati delovi sistema zasnovani na različitim tehnologijama)
        - da li prvo definisati interfejs servisa u jeziku implementacije pa onda generisati WSDL opis (kada obe strane u komunikaciji koriste istu implementacionu tehnologiju)
- **struktura**
    - `wsdl:definitions`
        - korenski element WSDL dokumenta
        - često se koristi za globalne namespace deklaracije
    - `wsdl:import`
        - dodaje sadržaj datog namespace-a u tekući WSDL dokument
        - način za modularizaciju WSDL dokumenata
        - dodati namespace definisan je u datom fajlu (preporučuje se navođenje apsolutne URL putanje zbog prenosivosti)
        - dodati namespace tipično sadrži zajedničke XML Schema definicije tipova
    - `wsdl:types`
        - kontejner za definicije tipova podataka koji se koriste dalje u dokumentu
        - kao jezik za definisanje tipova podataka najčešće se koristi W3C XML Schema (drugi se retko koriste)
        - ugrađeni W3C XML Schema tipovi podataka ne moraju se eksplicitno importovati
    - `wsdl:message`
        - za definisanje poruka koje se razmenjuju u komunikaciji sa web servisom
        - poruka se sastoji iz delova - *parts* (svaki deo pripada nekom tipu podataka)
    - `wsdl:portType`
        - definiše skup operacija koje se mogu izvršiti nad web servisom
        - operacija, kao element ovog skupa, može sadržati ulaznu i izlaznu poruku
        - četiri tipa operacija (*One-way*, *Request-response*, *Solicit-response*, *Notification*)
    - `wsdl:binding`
        - definiše konkretan protokol i format podataka za port type
        - može se koristiti standardan protokol (HTTP, SOAP, MIME, itd) ili definisati nov
        - port type predstavlja apstraktnu definiciju operacija
        - pomoću binding elementa ove operacije se konkretizuju u skladu sa izabranim protokolom
        - za svaku operaciju navedenu u portType sekciji mora se navesti odgovarajuća stavka u binding sekciji
    - `wsdl:service`
        - u prethodnim elementima nigde nije navedeno na kojoj URL adresi se nalazi web servis
        - element service nije obavezan
        - koristi se kada je potrebno definisati konkretan endpoint za web servis
        - servis je skup portova (moguće je definisati servis koji se sastoji od portova koji su dostupni na različitim adresama)


## UDDI
- UDDI = Universal Description, Discovery, and Integration
- **Koncepti**
    - softver jedne firme koristi web servise druge firme kako bi obavio poslovnu transakciju
    - u poslovnom okruženju sa puno partnera potrebno je organizovati podatke o njima
        - ne samo uobičajene podatke o samim partnerima, već i podatke o njihovim web servisima
        - takvih web servisa potencijalno ima mnogo
    - UDDI predstavlja jedno moguće rešenje za organizaciju kataloga poslovnih partnera i sa podacima o njihovim servisima
    - standard za objavljivanje podataka
        - o sopstvenoj poslovnoj organizaciji ("business") zajedno
        - podacima o pristupu softverskim servisima koje organizacija nudi
    - UDDI omogućuje formiranje registra je na globalnom (planetarnom) nivou
    - UDDI registar sadrži tri tipa informacija o organizaciji (omogucuju pronalazenje servisa)
        - **white pages** - osnovne informacije za kontakt, poreski identifikacioni broj (PIB), i slično
        - **yellow pages** - informacije koje opisuju usluge web servisa pomoću svrstavanja u razne kategorije
        - **green pages** - tehničke informacije koje opisuju funkcije web servisa, uključujući i podatke o lokaciji servisa
- **Korisnici**
    - **poslovni službenici**
        - koriste UDDI registar slično kao i Internet pretraživač
        - rezultat pretrage je skup podataka o nekoj organizaciji, ne samo njen URL
        - pošto svi podaci u UDDI registru nisu uvek *reader-friendly*, korisnici im mogu pristupati kroz razne portale
    - **softverski inženjeri**
        - koriste UDDI registar da pronađu podatke o odgovarajućim servisima
        - ili da registruju sopstveni servis
- **Arhitektura**
    - jedan logički jedinstveni servis na svetskom nivou
    - sastoji se iz više čvorova
    - lokalne baze podataka u čvorovima sinhronizuju se replikacijom
    - dodavanje podataka u registar odvija se na jednom čvoru
        - taj čvor postaje "vlasnik" tih podataka (tj. upravlja njima)
        - sve kasnije izmene nad podacima moraju se izvesti na istom čvoru
    - pristup bilo kom čvoru registra omogućava pristup svim podacima registra
    - javni svetski UDDI registar - UBR (UDDI Business Registry)
    - privatni UDDI registri po organizacijama (ne moraju biti deo UBR)
    - svaka organizacija može postaviti UDDI čvor i uključiti ga u UBR
- **Specifikacije**
    - sve specifikacije su dostupne na `http://www.uddi.org`
    - **UDDI replication** - opisuje procese i interfejse koje treba da implementira UDDI čvor kako bi obezbedio replikaciju u okviru UBR
    - **UDDI operators** - funkcionalni zahtevi postavljeni pred svaki čvor: skladištenje i backup podataka; nije obavezno za privatne registre
    - **UDDI programmer's API** - definiše funkcije za publikovanje i otkrivanje podataka o servisima; definisan je na nivou SOAP poruka
    - **UDDI data structures** - definiše strukture sadržane u SOAP porukama kojima se komunicira sa registrom
    - *UDDI XML API* - XML Schema dokument koji definiše tipove podataka i strukture za UDDI
- **Model podataka**
    - podaci u UDDI registru sastoje se iz entiteta koji se skladište u čvorovima i izražavaju se XML jezikom
    - model poseduje sledeće tipove entiteta
        - businessEntity
        - businessService
        - bindingTemplate
        - tModel
        - publisherAssertion
        - subscription
    - nad skupom podataka UDDI registra moguće je definisati više taksonomskih klasifikacija
        - mogućnosti za šifriranje (delatnosti, proizvoda, geografskog položaja)
    - kontrolisani i nekontrolisani šifarnici
        - *checked value sets*: unete vrednosti moraju pripadati konačnom skupu
        - *unchecked value sets*: unete vrednosti se ne proveravaju
- `businessEntity`
    - opisuje organizaciju
    - korenski element u UDDI modelu podataka
    - atributi
        - `businessKey`: indentifikator organizacije
        - `operator`: identifikator UDDI servera koji je vlasnik podataka
        - `authorizedName`: identifikator osobe koja je postavila informacije na server
    - podelementi
        - `discoveryURLs`: linkovi ka resursima sa više detalja o organizaciji
        - `name`: naziv organizacije
        - `description`: kratak opis organizacije
        - `contacts`: informacije za kontakt
        - `businessServices`: businessService elementi koji opisuju delatnost
        - `identifierBag`: identifikatori organizacije
        - `categoryBag`: šifrirane oznake delatnosti organizacije
- `businessService`
    - opisuje usluge (servise) koje nudi organizacija
    - atributi
        - `serviceKey`: identifikator usluge koju pruža organizacija
        - `businessKey`: identifikator organizacije (iz businessEntity elementa)
    - podelementi
        - `name`: naziv usluge
        - `serviceDescription`: kratak opis usluge
        - `bindingTemplates`: dalje opisuju uslugu
        - `categoryBag`: kategorizacija delatnosti
- `bindingTemplate`
    - opisuje tehničke informacije potrebne za pristup uslugama
    - atributi
        - `serviceKey`: identifikator usluge
        - `bindingKey`: identifikator bindingTemplate elementa
    - podelementi
        - `description`: kratak opis servisa
        - `accessPoint`: adresa na kojoj se nalazi web servis
        - `hostingRedirector`: referenca na drugi bindingTemplate
        - `tModelInstanceDetails`: reference na tehničke modele
- `tModel`
    - opisuje "tehnički model" nekog koncepta, npr. tip web servisa, protokol koji koristi web servis u cilju ponovnog korišćenja (*reuse*) istdefinicije kroz celokupan sistem
        - može biti izdvojen kao posebna stavka u bazi
        - predstavlja interfejs nekog servisa
        - ako se tModel definiše na nivou grupe organizacija, sve organizacije dele isttModel   (npr. aviokompanije)
        - WSDL
    - ukazuje na definicije web servisa
    - ima UUID koji se generiše prilikom registracije
        - koristi se za ukazivanje na tehničke detalje: transportni protokol, formati podataka
    - atributi
        - `tModelKey`: vrednost UUID-a tModela
        - `operator`: UDDI server koji je vlasnik tModela
        - `authorizedName`: identifikator osobe koja je publikovala informacije
    - podelementi
        - `name`: naziv tModela
        - `description`: kratak opis tModela
        - `overviewDoc`: resursi sa detaljnim opisom tModela
        - `identifierBag`: identifikatori tModela
        - `categoryBag`: kategorizacija tModela
    - kategorizacija (na primeru tModela)
        - način da tModel opišemo metapodacima pomoću kojih će neko pronaći naš servis
        - UDDI core models: predefinisani tModeli namenjeni klasifikaciji (oslanja se na WSDL-bazirani web servis)
- `publisherAssertion`
    - opisuje vezu jednog businessEntity sa drugibusinessEntity-ima
    - podelementi
        - `fromKey`: identifikator prve organizacije u vezi
        - `toKey`: identifikator druge organizacije u vezi
        - `keyedReference`: opisuje vrstu veze
- `subscription`
    - opisuje zahtev za praćenjem promena u okviru nekog entiteta
- *UDDI Programmer APIs*
    - *Inquiry API* - pronalaženje i preuzimanje podataka o entitetima u registru
    - *Publication API* - publikovanje i ažuriranje informacija o entitetima u registru
    - *Security Policy API* - autentifikacija UDDI klijenata
    - *Custody and Ownership Transfer API* - definisanje vlasništva nad entitetima među čvorovima UDDI registra
    - *Subscription API* - registracija radi praćenja promena nad željenim entitetima u registru
    - *Value Set API* - održavanje šifarnika
- *Inquiry API*
    - tri režima preuzimanja podataka
        - browse pattern (pregledanje širokog skupa podataka, izbor nekog entiteta i prelazak na drill-down)
        - drill-down pattern (na osnovu rezultata find_xx metoda - identifikatora entiteta - preuzimanje detalja o entitetu)
        - invocation pattern (na osnovu bindingTemplate podataka za dati servis on se može i pozvati)

## Mikroservisi
- Još jedan stil arhitekture softverskih sistema, u kome se velike složene aplikacije komponuju sklapanjem pojedinačnih servisa.
    - Koncept nije potpuna novina - predstavlja samo još jednan pristup implementaciji SOA
- Mikroservisi mogu biti nezavisno deployovani i međusobno slabo spregnuti
- Kod mikroservisnih arhitektura pojedinačni servisi obavljaju jedan zadatak
    - Taj jedan zadatak predstavlja jednu poslovnu funkciju celokupnog sistema
- **Osnovne karakteristike**
    - Svaki mikroservis moguće je razvijati u programskom jeziku koji je najpogodniji, nezavisno od svih ostalih
    - Komunikacija između mikroservisa se obavlja programskim interfejsima API-jima koji su nezavisni programskog jezika (npr. Representational State Transfer - *REST*).
    - Mikroservisi (moduli koji ih realizuju) imaju potpuno ograničen kontekst - ne moraju biti svesni nikakvih implementacionih detalja i arhitekture drugih mikroservisih modula.
- **Monolitne** aplikacije
    - **Višeslojne** arhitekture
        - klijentski sloj
        - sloj biznis logike
        - sloj podataka
    - nove funkcionalnosti
        - Obično se poveća složenost backend sloja
        - značajno zakomplikujemo srednji sloj
        - Kod je na sreću ipak organizovan po modulima, pa povećanje broja funkcija dovodi do povećanja broja modula u srednjem sloju aplikacije
    - skaliranje
        - Pokreće se više instanci backend aplikacija sa identičnim modulima kako bi odgovorile na povećane zahteve
        - lose ako su nam neke funkcije sistema više opterećene nego neke druge
- **Mikroservisni** pristup
    - Mikroservisi se orijentišu na jednostavnu poslovnu funkcionalnost - jedan zadatak, i kao takvi su po pravilu mali moduli
    - Nema pravila koliko mali moraju biti, i ne treba se koncentrisati na broj linija koda nego na funkcionalnost
    - Ključna je jednostavnost interfejsa - ona obično dovodi i do relativno male implementacije, ali to ne mora uvek biti slučaj
    - Mikroservisni modul treba tretirati kao nezavisnu aplikaciju ili nezavisni proizvod. Poželjno je da ima sopstveni repozitorijum za upravljanje kodom i sopstveni *build* i *deployment*
- **Reuseability** mikroservisa
    - Iako je ponovna iskoristivost poželjna nije i obavezna i nije jedini razlog njihovog uvođenja
    - Granularnost mikroservisa se takođe određuje na osnovu poslovnih potreba
    - Problem latentnosti servisa - ukoliko je previše usitnjen i zateva previše poziva ka drugim mikroservisima može se osetiti problem usporenja aplikacije
- Prednosti
    - Nema glomaznih modula sa "špageti" kodom
    - Komponente se mogu razvijati potpuno nezavisno jedna od druge
    - Komponente se mogu relativno jednostavno menjati
    - Moguće različito skaliranje različitih komponenti
- Pretpostavke za uspesnu mikroservisnu arhitekturu
    - 1 komponenta = 1 servis
    - "pametni" endpointi i "glupi" komunikacioni kanali
    - decentralizovano upravljanje
    - decentralizovano upravljanje podacima
    - automatizacija infrastrukture
    - dizajnirati arhitekturu da trpi otkaze
    - evolutivni dizajn
- Velicina komponente
    - Komponente se mogu formirati kao
        - biblioteke (moduli)
        - servisi
    - Mikroservisi promovišu modularizaciju pomoću servise
        - svaku komponentu možete pojedinačno zameniti
        - svaku komponentu možete nezavisno ažurirati
- Organizacija razvoja
    - klasicna
        - 1 tim po sloju, i svaki tim se bavi funkcionalnostima koje su u datom sloju bez obzira na to koji segment aplikacije opslužuju
    - usmerena na prozivod ili segment poslovanja
        - 1 tim se bavi jednim segmentom poslovanja, obezbeđuje funkcionalnost za jedan proizvod i sastoji se od ljudi svih profila koji su neophodni da taj segment proradi
        - Timovi se koncentrišu na samo jedan poslovni zadataka i mogu da komuniciraju direktno sa klijentima
- Decentralizovano upravljanje
    - Odluke o načinu implementacije se donose decentralizoanvo
    - Servisi podatke razmenjuju **iskljucivo** preko javno dostupnih API-ja, nema oslanjanja na deljene baze podataka
    - Omogućava svakom servisu da podacima upravlja na način koji je najpogodniji sa stanovišta tog servisa
- Automatizacija infrastrukture
    - Za efikasno korišćenje mikroservisnih arhitetkruea najverovatnije će biti neophodno da
        - Razvijate servise nezavisno
        - Servise nezavisno puštate u rad (deployment)
    - Morate obezbediti
        - mogućnost da dobijete serverse kapacitete brzo kako bi mogli da iskoristite skalabilnost rešenja
        - dobar monitoring kako bi bili u stanju da vidite kada servisi ne komuniciraju kako treba
        - brz deployment novih ili ažuriranih servisa
        - razvijenu kulturu jake integracije timova koji rade nadzor servisa u radu i tim akoji radi razvoj (*devops*)
    - Ključna stvar za uspeh mikroservisa je automatizacija svega navedenog
- Dizajniranje sistema tako da bude otporan na otkaze
    - Konceptom mikroservisa ukupna struktura sistema može ozbiljno da se zakomplikuje
    - Mnogo "pokretnih" delića koji mogu da otkažu
        - Pojedini servisi mogu imati greške
        - Pojedini servisi mogu raditi vrlo sporo
        - Celi serveri mogu pasti
        - Sa 60,000 HD ova 3 dnevno će verovanto otkazati
    - Ključna stvar - dizajnirati svaki servis pretpostavljajući da u nekom momentu sve ono od čega taj servis zavisi može prosto da nestane i bude nedostupno
        - servis tada mora otkazati *gracefully*
- Održavanje konzistencije
    - Jedno od pravila mikroservisa je ne koristiti deljene baze podataka
    - Neke podatke ipak verovatno koristi više servisa
    - Ažuriranje se šalje preko AJAX poziva
    - Nema garancije da će svi moduli obaviti ažuriranje u istom trenutku
    - Garantuje se da će oni u nekom momentu ažurirati podatke - **evenutal consistency**
    - Glavni problem je što različiti servisi mogu odgovoriti na zahtev u različitim vremenskim trenucima
    - Ako jedan zahtev rezultuje promenom resursa na jednom servisu, ali ostali još nisu procesirali korespondirajuće zahteve
        - Moguće je da se dobiju nekonzistentna stanja za korespondirajuće resurse
        - Mora se napisati dodatna logika da korektno obradi ovakve situacije