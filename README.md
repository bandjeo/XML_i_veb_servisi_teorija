# XML i veb servisi

## Sadrzaj
- [Inzenjering dokumenata](#inzenjering-dokumenata)
- [Markup jezici i XML](#markup-jezici-i-xml)
- [Document Type Definition (DTD)](#document-type-definition)
- [XML Namespaces](#xml-namespaces)
- [XML Schema](#xml-schema)
- [XML Parseri](#xml-parseri)
- [StAX](#stax)
- [SAX](#sax)
- [DOM](#dom)
- [JAXB](#jaxb)
- [XPath](#xpath)
- [XQuery](#xquery)
- [Vizuelizacija XML Dokumenta](#vizuelizacija-xml-dokumenta)
- [CSS](#css)
- [XSLT](#xslt)
- [XSL-FO](#xsl-fo)
- [RDF](#rdf)
- [RDFS](#rdfs)
- [SPARQL](#sparql)
- [Biznis procesi](#biznis-procesi)
- [SOA](#soa)
- [SOAP](#soap)
- [WSDL](#wsdl)
- [UDDI](#uddi)
- [Mikroservisi](#mikroservisi)


## Inzenjering dokumenata

- dokumenti i poslovni procesi
- analiza, dizajn i implementacija informacionih sistema
    - smanjeno vreme troskova
    - integracija i interoperabilnost
- **dokument**: fiksna i strukturirana kolicina informacija kojom se upravlja kao jedinicom i koja se razmnenjuje kao jedinica izmedju korisnika i sistema
    - zivotni ciklus
    - jako strukturirani - slabo strukturirani
    - sadrzaj + struktura + prezentacija (ref="XML.pdf/15")
- **identifikator** je objekat(skup metapodataka) koji moze da sluzi kao referenca na nesto sto ima identitet
- **poslovni proces** je skup aktivnosti(transformacija) ulaz -> izlaz -> cilj
    - rucno ili automatski
- **sistemi za upravljanje dokumentima** upravljaju zivotnim ciklusom dokumenta
    - rad sa dokumentima
    - rad sa metapodacima
    - indeksiranje i pretraga dokumenata
    - definisanje poslovnih procesa
    - saradnja izmedju korisnika
    - upravljanje verzijama dokumenta
    - bezbednost
    - integracija sa drugim sistemima
- Za implementaciju sistema za upravaljanje dokumentima koriste se**sistemi za upravljanje radnim tokovima**
    - dokument kao centar radnog toka
    - definisanje, izvrsavanje i nadgledanje radnih tokova
    - bazirani na dokumentima
- **resurs** moze biti bilo sta sto ima identitet
    - npr: elektronski dokument, slika, servis, kolekcija resursa
    - informacioni resursi se mogu preneti u poruci
    - neinformacioni resursi su oni drugi
- **reprezentacija resursa** je informacija koja reflektuje proslo, trenutno ili zeljeno stanje resursa, u formatu koji moze da se lako komunicira putem protokola i koja se sastoji iz skupa reprezentactionih metapodataka i potencijalno neogranicenim tokom reprezentacionih podataka
    - svaki resurs moze da ima vise reprezentacija
- **URI (Uniform resource identifier)** je niz znakova za identifikovanje apstraktnih ili fizickih resursa
    - URL, URN, ili oba
    - URI sema definise prostor imena identifikatora i moze dalje da ogranici sintaksu i semantiku identifikatora
- **URL (Uniform resource locator)** je podskup URI koji identifikuje resurse preko reprezentacije njihovog primarnog mehanizma pristupa
- **URN (Uniform resource name)** je podskup URI koji mora ostati globalno jedinstven i perzistentan cak i ako resurs prestane da postoji ili postane nedostupan
- **HTTP**
    - sigurne metode (ne menjaju stanje servera)
    - idempotentne metode (vise identicnih zahteva ima isti efekat kao jedan)
    - kodovi:
        - 1xx - info
        - 2xx - success
        - 3xx - redirect
        - 4xx - client error
        - 5xx - server error
- **informacioni set** skup elemenata i njihovih veza (stablo)
    - **RDF** graf (vise o tome kasnije :)


## Markup jezici i XML
- **markup** (tag, code) oznaka koja opisuje deo sadrzaja
    - koriscen i na papiru (naslov, citati...)
    - ne predstavlja sadrzaj
    - uputstvo kako obraditi sadrzaj
    - ne prikazuje se eksplicitno (krajnji korisnik ne vidi markup tagove)
    - ako se korisiti za definisanje prezentacije dokumenta vidljiv (broj poglavlja, naslov, broj strane)
    - definisu ih:
        - firme
        - otvoreni standardi
    - rad se vise markup istovremeno je tehnicki komplikovan i trazi puno rucnog rada
    - korišćenje otvorenih standarda bi trebalo da pojednostavi razmenu podataka između razlicitih sistema, softvera i/ili ucensnika u proizvodnji sadrzaja
    - nejasan markup (osnovni razlozi nastanka su fokus na prikaz dokumenta i ogranicenost na spostveni, zatvoren sistem)
    - otvoreni standardi za markup se fokusiraju na markiranje *strukture* i *znacenja*
- **HTML**
    - hijerarhija elemenata
    - unapred definisani tagovi
    - definisan pomocu XML-a
- **XML** (eXtensible Markup Language)
    - ne definise tagove unapred (korisnik ih sam definise)
    - jezik za definisanje markup jezika
    - ciljevi
        - da odgovara upotrebi na Internetu
        - mogućnost korišćenja od strane različitih aplikacija
        - (jednosmerna) kompatibilnost sa SGML-om (Standard Generelized Markup Language)
        - da se programi za obradu XML dokumenata pišu lako
        - jednoznačnost prilikom obrade XML dokumenata
        - XML dokumenti čitki i rezonski jasni
        - dizajn XML-a se vrši brzo
        - dizajn XML-a je formalan i koncizan
        - kreiranje XML dokumenata je lako
        - konciznost je od minimalne važnosti
    - familija standarda
        - XSL (Extensible Stylesheet Language)
            - XSLT (Transformations)
            - XSL-FO (Formatting Objects)
        - XPath (oznacavanje strukture)
        - XLink (povezivanje)
        - XQuery (pretrazivanje)
- **element** je cvor u hijerarhijskoj strukturi dokumenta (moze sadrzati druge cvorove)
    - **tag** je tekstualna oznaka (markup) za pocetak ili kraj elementa
        - pocenti (otvarajuci) tag `<tag>`
        - zavrsni (zatvarajuci) tag `</tag>`
    - **sadrzaj** elementa se nalazi izmedju pocetnoh i zavrsnog taga
        - tekst
        - podelementi
        - mesavina
        - prazan
    - ako je prazan moze da se spoji \<tag/>
    - element moze da ima atribute
- **atribut**
    - naziv
    - sadrzaj (nestrukturiran tekst)
    - najcesce se smatrja posebnim cvorom stabla
- dobro formirani XML dokument (moze masinski da se obradi)
    - ima jedan korenski element
    - elementi se mogu ugnjezdavati ali ne i preklapati
    - vrednosti atributa moraju biti unutar navodnika
    - element ne moze imati dva atributa sa istim imenom
    - komentari i procesne instrukcije se ne smeju nalaziti unutar
taga
- generalna pravila
    - elementi - podaci; kada nismo sigurni; lakse se prilagode
    - atributi - metapodaci; ne mogu se strukturirati
- davanje imena elementima i atributima
    - case sensitive
    - slova, cifre, "_", "-", ":" i "."
    - mora poceti sa slovom ili "_"
    - ne sme poceti sa *xml*
- ostali delovi XML dokumenta
    - **komentari**
        - navode se izmedju `<!-- i --\>`
        - ignorisu se kao sadrzaj (ne prikazuju se, ne obradjuju se programski)
        - bilo gde izvan taga
    - **procesne instrukcije**
        - navode se izmedju `<? i ?>`
        - predstavljaju instrukcije softveru
        - nisu namenjene krajnjem korisniku (čoveku)
        - nisu deo sadržaja dokumenta
        - mogu se nalaziti bilo gde izvan taga
        - xml deklaracija na pocetku dokumenta 
        `<?xml **version**="1.0" **encoding**="utf-8" **standalone**="yes"?>`
    - **entiteti**
        - ugradjeni (unapred definisani)
        - \&lt; = &lt;
        - \&amp; = &amp;
        - \&gt; = &gt;
        - \&quot; = &quot;
        - \&apos; = &apos;
    - **CDATA sekcije**
        - navode se izmedju `<![CDATA[i]]>`
        - sadrzi tekst koji se interpretira direktno, bez zamene entiteta


## Document Type Definition
- **DTD** fajl (dokument) opisuje format klase/familije/tipa XML dokumenata
    - koji elementi i entiteti se mogu pojaviti na kom mestu u dokumentu
    - sta je sadrzaj element i atributa
    - dokument je validan ako odgovara svom DTD-u
- **deklaracija elementa**
    - opsti oblik `<!ELEMENT naziv (specifikacija_sadržaja)>`
    - naziv postuje pravila imena elemenata i atributa
- **specifikacija sadrzaja elementa**
    -  #PCDATA
        - sadrzaj elementa je tekst, bez podelemenata
        - tekst je parsiran (reference na entitete su razresene)
        - primer `<!ELEMENT phone_number (#PCDATA)>`
    - sekvenca podelemenata
        - podelementi se razdvajaju zarezom
        - uz naziv podelementa navodi se oznaka broja ponavljanja 
            - ? = (0..1)
            - \* = (0..∞)
            - \+ = (1..∞)
            - podrazumevano = (1..1)
        - redosled i broj ponavljanja podelemenata su bitni
        - primer: `<!ELEMENT name (first_name, last_name?)>`
    - izbor
        - podelementi se razdvajaju uspravnom crtom
        - izbor moze obuhvatati 2+ podelementa
        - primer: `<!ELEMENT methodResponse (params | fault)>`
    - upotreba zagrada
        - sekvence, izbori i sufiksi se mogu kombinovati
    - mesani sadrzaj
        - element sadrzi i tekst i podelemente
        - definise se kao izbor ciji prvi element je #PCDATA, ostali lementi su moguci podelementi, a cela grupa ima broj ponavljanja \*
        - primer: `<!ELEMENT definition (#PCDATA | term)*>`
        - nije moguce navesti broj niti redosled ponavljanja podelemenata i teksta
        - deklaracija mesanog sadrzaja se ne moze koristiti za dalje grupisanje
    - prazan sadrzaj
        - kljucna rec *EMPTY*
        - primer: `<!ELEMENT img EMPTY>`
    - bilo kakav sadrzaj
        - oznacava se kljucnom reci *ANY*
        - uključuje tekst, podelemente, isti element ponovljen rekurzivno
        - nalik mešanom sadržaju bez fiksirane liste podelemenata
        - podelementi koji se pojavljuju u sadržaju moraju biti deklarisani
        - u praksi se koristi samo u toku razvoja DTD-a
        - primer: `<!ELEMENT page ANY>`
- **deklaracija atributa**
    - opsti oblik: `<!ATTLIST imeElementa imeAtr tipAtr default>`
    - naziv atributa mora da odgovara pravilima za formiranje imena
    - tip atributa se bira iz konačnog skupa
    - obaveznost atributa se bira iz konačnog skupa
    - jedna deklaracija može da obuhvati više atributa jednog elementa
        - u praksi se svi atributi jednog elementa stavljaju u jednu deklaraciju
        - u praksi se deklaracija atributa navodi odmah ispod deklaracije elementa
    - moguci tipovi
        - CDATA: bilo koji dobro formirani tekst
        - NMTOKEN: XML name token
        - NMTOKENS: jedan ili više NMTOKEN-a razdvojenih razmacima
        - nabrajanje mogućih vrednosti (delimiter "|")
        - ID: string koji je XML ime i jedinstven je u okviru celog dokumenta (samo jedan ID po elementu)
        - IDREF: postojeca vrednost ID atributa nekog elementa u istom dokumentu
        - IDREFS: niz IDREF vrednosti razfvojenih razmakom
        - ENTITY: ime neparsiranog entiteta koje je deklarisan u DTD-u
        - ENTITIES: više ENTITY vrednosti razdvojenih razmakom
        - NOTATION: sadrži ime notacije koja je deklarisana u DTD-u
    - obaveznost pojavljivanja atributa
        - \#IMPLIED: atribut nije obavezan; može se navesti ali i ne mora
        - \#REQUIRED: atribut je obavezan; mora se navesti
        - \#FIXED "value" : atribut nije obavezan, ali se smatra da uvek postoji u elementu i da ima datu fiksnu vrednost value; ako se eksplicitno navede u elementu, mora imati baš tu vrednost
        - "default": atribut, ako se ne navede, ima podrazumevanu vrednost default datu pod navodnicima
- **deklaracija entiteta** - pored predefinisanih, moguce je deklarisati nove
    - opsti oblik `<!ENTITY naziv "sadržaj">`
    - svaki "naziv" u dokumentu bice zamenjeno sadrzajem, prilikom parsiranja (ucitavanja) XML dokumenta
    - sadrzaj entiteta moze da sardzi druge entitete (bez rekurzije)
    - eksterni entitet - smesten u posebnom fajku, izvan DTD-a
        - opsti oblik eksternog: `<!ENTITY naziv SYSTEM "adresa_fajla">`
    - moze imati javni identifikator `<!ENTITY name PUBLIC "pubid" SYSTEM "sysid">`
        - javni identifikator može da identifikuje dobro poznati resurs (iz liste takvih) koji je javno dostupan
        - liste javno dostupnih resursa su slabo razvijene
        - retko se koriste
    - parametarski entiteti - entiteti koji se definisu za potrebe DTD-a a ne XML dokumenta
        - opsti oblik: `<!ENTITY % ime "vrednost">` ili `<!ENTITY % ime "vrednost">`
    - neparsirani entiteti - fajlovi koji sadrze ne-XML podatke
        - opsti oblik `<!ENTITY naziv PUBLIC "pubid" notacija>` ili `<!ENTITY naziv SYSTEM "sysid" notacija>`
        - referenca na neparsirani entitet može se naći samo kao vrednost atributa tipa ENTITY
        - notacija predstavlja dodatnu informaciju za XML aplikaciju kako da rukuje podacima iz neparsiranog entiteta
- **deklaracija notacije**
    - notacija = pomocni podaci za XML aplikaciju prilikom rukovanja sa neparsiranim entitetima
    - opsti oblik `<!NOTATION naziv PUBLIC "pubid">` ili `<!NOTATION naziv SYSTEM "sysid">`
    - nema standarda niti preporuke kako treba da izgledaju notacije, sve je stvar aplikacije
- **povezivanje XML dokumenta sa DTD-om**
    - takozvani prolog XML dokumenta sadrzi
        - XML deklaraciju
        - deklaraciju tipa dokumenta koja povezuje dokument sa DTD-om
    - opsti oblik `<!DOCTYPE koren (PUBLIC "pubid" | SYSTEM) "sysid" [<!-- interne deklaracije -->]>`
    - uslovne sekcije INCLUDE i IGNORE


## XML Namespaces
- svako moze da definise sopstvenu XML gramatiku
- ukoliko zelimo da koristimo razlicite gramatike moze doci do poklapanja imena
- resenje:
    - uciniti da sva imena budu jedinstvena
    - mozemo svakom elementu dodati prefiks (zavisno od toga gde su definisani)
- skup elemenata sa istim prefiksom je **prostor imena** (namespace)
    - prostor imena ≠ tip dokumenta
    - jedan tip dokumenta moze ukljucivati elemente iz vise prostora
    - jedan element moze biti koriscen u vise tipova dokumenata
- koncept prefiksa nije dovoljno robustan
    - vise ljudi moze da se odluci da koristi isti prefiks
    - morala bi da postoji organizacija koja se bavi administarcijom prefiksa
- koristimo postojeci sistem - internet
    - prostori imena identifikuju se nazivom
    - naziv = URI
    - URL je pogodniji od URN
        - lakse je napraviti jedinstveni URL (npr. firma vec poseduje domen)
        - zloupotreba tudjeg domena se ne moze izbeci, izbegavaju se slucajne kolizije
        - DTD se moze postaviti na taj URL i time uciniti javno dostupnim
        - koristi se puna adresa (`http://www.mojafirma.com/primer` ≠ `http://mojafirma.com/primer`)
    - identifikator prostora imena ne mora da nosi nikakvo znacenje
    - `http://www.mojafirma.com/primer:name` je predugacko i nezgrapno (moze da narusi pravila imena)
- **kvalifikovano ime** (qualified name, QName)
    - lokalno ime + namespace
    - umesto punog naziva namespace-a, koristi se prefiks (XML dozvoljen)
    - prefiks se povezuje sa svojim prostorom imena
    - ime prefiksa vise nije bitno
    - primer: `xmlns:pers="http://www.ftn.ns.ac.yu/dtds/person.dtd"`
    - **podrazumevani** prostor imena
        - njegovi elemeni se navode bez prefiksa
        - primer `xmlns="http://www.ftn.ns.ac.yu/dtds/person.dtd"`
    - u jednom dokumentu moze se koristiti vise prostora imena
        - prefiksi imaju znacenje samo u *okviru*(element + podelementi) elementa u kom se nalaze
        - namespace mozemo iskljuciti xmlns=""
    - prefiks se moze koristiti i ispred atributa
        - aplikacija to interpretira po volji
- sto se tice XML aplikacije je svejedno koji pristup koristimo:
    - uvek koristiti prefiks
    - koristiti jedan defaut namespace, ostali sa prefiksom
    - svuda redefinisati namespace
- namespace i DTD
    - DTD je definisan pre XML Namespaces standarda
    - DTD ne podrzava namespaces potpuno
    - elementi se moraju definisati sa prefiksom koji je unapred fiksan
    - namespace deklaracije se tretiraju kao atributi (nije svejedno gde deklarisemo namespace)


## XML Schema
- sta nije dobro kod DTD?
    - ne-XML sintaksa, cudna
    - slaba podrska za namespace
    - nema tipizacije podataka (narocito lose za sadrzaj elementa)
    - ogranicena prosirivost
    - ogranicene mogucnosti za opisivanje strukture podataka
        - ne može se nametnuti broj podelemenata bez nametanja redosleda
        - ne može se nametnuti redosled i broj podelemenata kada se koristi mešani sadržaj
- **XML Schema** je XML dokument koji opisuje strukturu drugih dokumenata
    - prevazilazi mane DTD-a (DTD i dalje moze da se koristi)
    - postoji vise standarda
    - XML Schema standard propisuje W3C
        - najrasireniji, najmocniji, najkomplikovaniji
        - nema patent ili druge restrikcije
- povezivanje šeme sa dokumentom
    - standardni XML Instance namespace
        - identifikator je `http://www.w3.org/2001/XMLSchema-instance`
        - uobicajeni prefiks je *xsi*
        - cetiri atributa (*xsi:type, xsi:nil, xsi:schemaLocation, sxi:noNamespaceSchemaLocation*)
    - atribut *xsi:schemaLocation* oznacava lokaciju seme koja se definise za dati dokument
        - identifikator namespace-a + adresa fajla
    - atribut *xsi:noNamespaceSchemaLocation* oznacava lokaciju seme za default namespace
    - *target namespace* u `<schema>` elementu
        - u XSD fajlu targetNamespace atribut treba da gadja URL namespace
        - default moze da bude XMLSchema a moze i targetNamespace
        - ako ne se navede targetNamespace nema prefiksa i sve pripada default namespace-u
- cetiri osnovna elementa seme
    - *xsd:element* deklarise element i dodeljuje mu tip
    - *xsd:attribute* deklarise atribut i dodeljuje mu tip
    - *xsd:simpleType* definise novi prosti tip
    - *xsd:complexType* definise novi slozeni tip
- deklaracija vs definicija
    - deklarisanje - bice u instanci seme (elementi i atributi)
    - definisanje - koriste se u okviru seme (tipovi, grupe atributa, itd.)
- dekalracije mogu da budu ugnjezdene ili da se pozivaju na vec definisan tip
- definicija tipa
    - svaka deklaracija novog tipa se oslanja na neki od postojecih tipova
    - postoje tipovi ugradjeni u XML Schema Part 2: Datatypes
- **definicija novog prostog tipa**
    - prosti tip ima samo vrednost
    - novi prosti tipovi definisu se na osnovu postojecih - ugradjenih
    - **restrikcija**
        - skup mogucih vrednosti novog tipa je podskup vrednosti osnovnog
        - navode se pomocu 12 *facet-a* (length, minLength, maxLength, pattern...)
            - enumeration i pattern povezani sa or, ostali sa and
    - **lista**
        - tip koji definisemo predstavljace listu elemenata nekog tipa
        - elementi liste su razdvojeni razmacima
        - primer: `<bingo>4 9 12</bingo>`
        - nije moguce napraviti listu u listi niti listu slozenih tipova
        - *facet*-i (length, minLength, maxLength, enumeration, pattern)
    - **unija**
        - vrednost novog tipa moze biti vrednost bilo kog tipa koji je clan unije
- **deklaracija atributa**
    - atributi moraju biti prostog tipa
    - uvek na kraju, posle elementa
    - uvek ugnjezdeni u deklaraciju elementa kome pripadaju
- **definicija slozenog tipa**
    - slozeni tip pored vrednosti moze da ima atribute i podelemente
    - za podelemente koristimo jedan od **modela sadrzaja** (*sequence*, *choice*, *all*)
        - *minOccurs* i *maxOccurs* atributi svakog elementa odredjuju broj njegovog ponavljanja
    - *sequence* je sekvenca podelemenata ili drugih modela sadrazaja
        - redosled podelemenata je bitan
        - broj pojavljivanja podelemenata je bitan
        - cela sekvenca moze da se ponavlja (ima atribute minOccurs i maxOccurs)
    - *choice* - izbor jednog od podelemenata
    - *all* - neuredjeni skup
        - u sadrzaju se mogu navesti podelementi u bilo kom redosledu
        - svaki podelement se mora pojaviti tacno jednom
        - ne moze da sadrzi sekvence ili izbore
        - ne moze da bude ukljucen u sekvence ili izbore ili drugi *all*
    - *mesani tip*
        - attribut *mixed* ima vrednost *true*
        - tekst moze biti isprepletan sa podelementima
    - novi slozeni tip na osnovu postojeceh dobija se prosirivanjem ili restrikcijom
    - slozen tip moze da bude apstraktan
        - atribut *abstact="true"*
        - ne mogu postojati njegove instance
        - mogu postajti istance njegovih izvedenih tipova
- **grupisanje elemenata**
    - elementi se mogu grupisati
    - grupa ima svoje ime i moze se referencirati na drugom mestu
    - mora biti globalna i ne moze da ima atribute
- *fixed*, *default* i *nil* vrednosti
    - *fixed* i *defulat* omogucavaju da se navede prazan element
    - *nil* - atribut *nillable="true"* odnosno *xsi:nil="true"*; nije isto sto i prazan element
- **rad sa vise sema**
    - dokument moze da sadrzi elemente iz razlicitih sema
    - validacija se moze primeniti na ceo dokument ili na pojedinacne elemente
    - *lax* validacija - validator ne proverava one elemente za koje ne postoji sema
    - *strict* validacija - svi elementi moraju imati semu i biti validni po njoj
    - element `<xsd:include>`
        - pristup delovima drugih sema
        - ove seme kojima se pristupa moraju imati isti targetNamespace
        - ukoliko ukljucena sema nema namespace preuzece ga od seme u kojoj se koristi
        - isto kao da smo sve stavili u jedan fajl
    - element `<xsd:import>` sluzi za seme koje imaju razliciti targetNamespace
    - elementi `<xsd:include>` i `<xsd:import>` moraju se nalaziti ispred deklaracija elemenata/atributa i definicija tipova u šema dokumentu
    - `<any>` je bilo koji element
        - omogucava dodavanje elemenata koji ne definise data sema
        - postavljanjem atributa namespace mozemo joj dodeliti namespace (any, targetNamespace, other, local, URL)
    - `<\anyAttribute>` analogno *any* samo za atribute
- zamena elemenata
    - moguce je da se element Y u dokumentu nadje umesto elementa X
    - X se zove *head*
    - primer: 
        - `<xsd:element name="X" type="xsd:string"/>`
        - `<xsd:element name="Y" substitutionGroup="X" type="xsd:string"/>`
    - svi elementi koji pripadaju grupi moraju biti globalni
    - tip elementa zamene mora biti ili jednak tipu glave ili izveden iz njega
    - ako se prilikom deklarisanja tipa zamene ne navede tip, podrazumeva se tip glave
    - zabrana zamene radi se pomocu atributa `block="substitution"`
    - zamena elementa je tranzitivna
    - zamena elementa nije simetricna
- anotacija
    - element `<xsd:annotation>` sluzi za dokumentovanje seme
        - podelement `<xsd:documentation>` - za coveka
        - podelement `<xsd:appinfo>` - za masinu
    - mogu se smestiti ispred svake globale komponente i na pocetku lokalnih
    - `<xsd:documentation>` ima dva atributa
        - *source*: URL do fajla sa dodatnim podacima
        - *xml:lang*: jezik na kome je napisana dokumentacija
    - `<xsd:appinfo>` ima samo atribut *source*
- **jedinstvenost**
    - sadrzaj elementa moze biti jedinstven (*unique*)
    - vrednosti atributa koji nisu tipa ID mogu biti jedinstvene
    - kombinacija sadrzaja elemenata i atributa moze biti jedinstvena
    - moze se definisati opseg u kome se proverava jedinstvenost
    - element `<unique>` ima istu strukturu kao i `<key>` element
    - validator ce proveriti da li su oznacene vrednosti jedinstvene ako postoje
- **kljucevi**
    - pravi se razlika izmedju jedinstvene vrednost (*unique*) i kljuca (*key*)
    - *key* je element, atribut ili kombinacija vise njih koja:
        - uvek postoji (minOccurs>0)
        - ne moze biti nillable
        - je *unique* po vrednosti
    - element `<key>`
        - mora biti smesten unutar elementa posle definicije sadrzaja i deklaracije atributa
        - podelement `<selector>` odredjuje skup elemenata na koje se kljuc odnosi (opseg)
        - podelement `<field>` odredjuje atribut ili element cija vrednost predstavlja kljuc (ponovljiv)
        - identifikuju se [XPath-om](#xpath)
    - **referenciranje kljuceva**
        - element oznacen pomocu `<keyref>` mora sadrzati vrednost nekog atributa *key*
        - broj i tip polja u referenci na kljuc mora odgovarati broju i tipu polja u kljucu
        - polozaj odredjuje opseg jedinstvenosti
- **konflikt imena**
    - isto ime moze da se koristi za vise razlicitih elemenata
    - postoje situacije kada koriscenje istog imena nije dozvoljeno
    - imena komponenti koje se nalaze u semi su smestena u prostore simbola (*symbol space*)
    - *symbol space* odvojen za
        - definicije tipova, deklaracije elemenata i atributa
        - globalne komponente seme i svaki definisani tip
    - dozvoljeno
        - isto ime u različitim symbol spaces
        - isto ime u različitim namespaces
        - isto ime, isti symbol space, isti tip
    - zabranjeno
        - isto ime, isti symbol space, različit tip
- *namespace* ima sledece karakteristie koje ga razlikuju od *symbol space*
    - samo globalni elementi su u namespace-u
    - lokalni elementi su povezani (associated) sa globalnim
    - može postojati više atributa sa istim imenom
    - nisu smešteni svi u namespace, već su povezani sa elementima koji su u namespace-u
- kvalifikovanje elemenata
    - lokalni elementi formalno ne spadaju u targetNamespace ali su u njemu preko svoje veze sa globalnim elementima
    - element je kvalifikovan ako je asociran sa *namespace*-om
    - `elementFormDefault="qualified"` - svi elementi mogu biti kvalifikovani
    - `elementFormDefault="unqualified"` - samo globalni elementi mogu biti kvalifikovani
- kvalifikovanje elemenata u XPath izrazima
    - ako je elementFormDefault="qualified" elementi u XPath izrazima se moraju kvalifikovati, čak i kada je targetNamespace ujedno i default namespace
    - ako je elementFormDefault="unqualified" tada se elementi u XPath izrazima ne kvalifikuju

## XML Parseri
- moguce je napraviti parser koristesi tehnike naucene na programskim prevodiocima
- bolje koristiti vec gotove
    - manje posla
    - manja verovatnoca greske
- progarmski modeli za parsiranje XML dokumenata
    - streaming parseri
        - *pull* ([StAX](#stax) parseri)
        - *push* ([SAX](#sax) parseri)
    - *DOM* parseri
    - *XSL-T* parseri
- *push* parseri
    - implementiraju programski model u kome XML parser salje (gura) podatke programu koje ga koristi nailazeci na elemente XML informacionog skup (element, atribute, test, itd.)
- *pull* parseri
    - pull parseri implementiraju prgoramski model u kome programi koji ih koriste pozivaju metode XML parsera (vuku podatke) kada im treba element XML informactionog skupa
- [StAX](#stax)
    - pull streaming
    - lako upotrebljiv
    - ne podrzava [XPath](#xpath)
    - nisko zahtevni za CPU
    - cita ili pise XML
- [SAX](#sax)
    - push streaming
    - teze upotrebljiv
    - ne podrzava [XPath](#xpath)
    - nisko zahtevni za CPU
    - cita XML
- [DOM](#dom)
    - in memory tree
    - lako upotrebljiv
    - podrzava [XPath](#xpath)
    - visoko zahtevni za CPU
    - cita i pise XML
    - podrzava CRUD
- *TrAX*
    - XSLT rules
    - teze upotrebljiv
    - podrzava [XPath](#xpath)
    - visoko zahtevni za CPU
    - cita i pise XML


## StAX
- pull parser
- koristi se i za citanje i za pisanje
- XML dokumente parsira koriscenjem iteratora
- *Cursor* API koristi kursor koji se krece od pocetka do kraja XML dokumenta
- *Iterator* API predstavlja XML dokument kao niz diskretnih dogadjaja koji se mogu obraditi

## SAX
- definisan za razlicite jezike (Java, C++)
- specifikacije slicne za svaki jezik
- nije W3C standard ali je *de facto* standard
- koncept
    - parsiranje je *event-driven*
    - parser generise dogadjaje (npr. poceo dokument, poceo element, zavrsio element)
    - nas kod obradjuje dogadjaj (*handler*-i koje poziva parser putem *callback*-a)
- *handlers*
    - dogadjaji koje obradjuju: *startDocument(), endDocument(), startElement(), endElement(),
characters(), processingInstructions()*
    - *ContentHandler* (dogadjaji), *ErrorHandler* (greske), *DTDHandler* (DTD), *EntityResolver* (Spoljni entiteti)
    - *DefaultHandler* nasledjuje sve prethodne interfejse praznim metodama, redefinisu se potrebne
- rezultati
    - ocuvani whitespace (sem kod atributa)
        - nema DTD na raspolaganju pa pretpostavlja da svaki element ima mixed content model
    - komentari su ignorisani
        - trebalo bi implementirati *LexicalHandler*
    - prazni elementi: `<item/>` se događajima predstavlja kao `<item></item>`
- *Locator* - objekat koji sadrži podatke o lokaciji na kojoj se desio
    - validan samo u trenucima poziva event-handling metoda
- obrada gresaka
    - *SAXException* može da sadrži i izuzetak koji se desio u event-handleru
    - *SAXParseException* nasledjuje *SAXException* i sadrži informacije o redu u kome je greška događaj
    - tri nivoa gresaka
        - *warning* - npr. element definisan dva puta u DTD-u (jeste greška, ali ne pravi probleme)
        - *error* - npr. dokument nije validan
        - *fatalError* - npr. dokument nije dobro formiran
- CDATA sekcije
    - reference na entitete parser automatski zamenjuje njihovim vrednostima
    - CDATA sekcije parser automatski pretvara u nizove znakova
- parsiranje uz validaciju
    - dokument moze da poseduje svoj DTD ili referencu na spoljasnji DTD
    - nevalidirajući parser ignoriše whitespace tamo gde je to moguće
    - validirajući radi sve to plus validaciju
    - kreiranje parsera - izbor fabrike, *setValidating(boolean)*, *setNamespaceAware(boolean)*
    - moze i pomocu seme
        - `setProperty("http://java.sun.com/xml/jaxp/properties/schemaLanguage", "http://www.w3.org/2001/XMLSchema")`
    - ako povezemu semu programski sema u dokumentu se ignorise

## DOM
- **Document Object Model**
    - W3C standard za objektno-orijentisanu reprezentaciju dokumenata sa hijerarhijskom strukturom - stablo
    - varijante za razlicite jezike i dokumente
    - rezuletat parsiranja je stablo objekata
        - stalno prisutno u memoriji, za ceo dokument
        - redosled obrade elemenata se ne mora poklapati sa redosledom u dokumentu
    - mozemo serijalizovati stablo nazad u XML
    - problem sa zauzecem memorije
        - veliki dokumenti
        - puno dokumenata u isto vreme
- Java specificnosti

## JAXB
- JAXB (Java Architecture for XML Binding) je framework za generisanje Java klasa na osnovu  TD ili XML Schema šema (i obrnuto) i za transformaciju XML dokumenata u graf Java objekata (i obrnuto)
- JAXB parseri rade na višem nivou apstrakcije od SAX, StAX-a i DOM parsera
- JAXB parseri predstavljaju XML dokumente kao Java klase iz odreenog domena
- JAXB se može posmatrati kao jedan nacin (de)serijalizacije stanja Java objekta
- Koriste se za parsiranje transakcionih dokumenata (koji se relativno lako mapiraju na java objekte)
- za parsiranje narativnih dokumenata (koji se tesko mapiraju na java objekte) koriste se drugi parseri
- proces
    - Pomocu binding prevodioca DTD ili XML Schemu prevesti u Java klase (ili obrnuto)
    - Pomocu Java prevodioca prevesti Java klase (u byte kod)
    - Napisati Java program koji transformiše XML dokumente u graf Java objekata (i obrnuto)
- JAXB koristi podrazumevana pravila povezivanja
- Podrazumevana pravila povezivanja mogu se promeniti anotacijama u XML šemi ili Java klasi

## XPath
- definicija
    - jezik za označavanje delova XML dokumenta
    - zasniva se na konceptu navigacije kroz stablo dokumenta
    - ima biblioteku standardnih funkcija
    - W3C standard
- **izrazi**
    - izraz je namenjen za označavanje čvora ili skupa čvorova u dokumentu
    - ovi izrazi liče na izraze za rad sa fajl-sistemom
- XPath sadrži oko 100 ugrađenih funkcija
- **čvorovi**
    - XML dokument se, sa stanovišta XPath-a, posmatra kao stablo
    - vise tipova cvorova
        - element
        - atribut
        - tekst
        - namespace
        - procesna instrukcija
        - komentar
        - dokument (koren)
    - odnosi medju cvorovima - roditelj, dete, brat/sestra, predak, naslednik
    - koncept tekuceg cvora (cvor gde se nalazimo)
- **putanja**
    - sastoji se iz više koraka razdvojenih znakom "/"
    - apsolutna putanja: počinje znakom /
    - relativna putanja: ne počinje znakom /
    - svaki korak se izračunava u odnosu na čvorove u tekućem skupu čvorova (node-set)
- **korak**
    - osa kretanja + test cvor + nula ili vise predikata
    - opsti oblik `osa::test[predikat]`
- **ose**:
    - *ancestor* - svi preci
    - *ancestor-or-self - svi preci ili sam cvor
    - *attribute* - svi atributi (skraceno @)
    - *child* - sva deca (default)
    - *descendant* - svi potomci (skraceno //)
    - *descendant-or-self* - svi potomci ili sam cvor
    - *following* - sve u dokumentu iza zatvarajuceg taga tekuceg cvora
    - *following-sibling* - sva braca posle tekuceg cvora (se moze pisato kao ../)
    - *namespace* - svi namespace cvorovi tekuceg cvora
    - *parent* - roditelj (skraceno ..)
    - *preceding* - sve u dokumentu iza pocetnog taga tekuceg cvora
    - *preceding-sibling* - sva braca pre tekuceg cvora
    - *self* - tekuci cvor (skraceno .)
- **predikati**
    - koriste se za pronalazenje cvora koji zadovoljava dati uslov
    - osnovna primena: filtriranje
    - uvek se pisu unutar uglastih zagrada `[...]`
    - unutar predikata mogu se koristiti funkcije, operatori, @ za atribut
    - `[position() = X]` je skraceno `[X]`
- funkcije i operatori su ugradjeni i ima ih mnogo
- oznacavanje vise putanja odjednom
    - navodjenjem vise *XPath* izraza povezanih operatorom "|"
    - rezultat je unija skupova čvorova dobijenih osnovnim izrazima

## XQuery
- standardni upitni jezik za XML
- W3C standard
- ekvivalent SQL-a za XML dokumente
- **tipovi podataka**
    - svi ugradjeni XML Schema tipovi
    - jos 7 tipova vezanih za tipove cvorova u stablu dokumenta
    - jos 6 tipova specificnih za XQuery
    - svaka XQuery vrednost je sekvenca koja sadrzi 0 ili vise elemenata
        - element sekvence je *singleton* ako sadrzi samo jedan element `(1)=1`
        - sekvenca moze biti prazna `()`
        - ne moze da sadrzi druge sekvence
        - sekvence se poravnavaju `(0, (), (1, 2)) = (0, 1, 2)`
    - svaki *singleton* ima svoj tip izveden iz `item()`
    - tip je apstraktan, ne moze se instancirati
    - pise se sa zagradama da bi se razlikovao od krisnickih tipova istog imena
        - da bude nalik XPath testu cvora
    - tip moze da bude XML cvor ili atomicka vrednost
    - *XML cvorovi* izvedeni iz `node()`
        - *attribute(), comment(), document()...*
    - *atomicke vrednosti* nasledjuju `xdt:anyAtomicType`
        - *xs:boolean, xs:string, xs:data...*
    - sekvenca ima tip koji se sastoji od 
        - imena tipa ili `empty()`
        - (opciono) indikator ponavljanja (*, +, ?)
        - primeri: `item()`, `item()*`, `xsd:integer*`
    - staticki tip (*compile-time*)
    - dinamicki tip (*run-time)
        - tip dobijenog rezultata
        - vrednost rezultata je instanca tog tipa
    - provera tipova moze da se vrsi *compile-time* ili *run-time*
- whitespace i komentari
    - posebni znakovi za whitespace (npr. U+0020 = space)
    - komentar moze da se pojavi bilo gde na mestu whitespace znakova
        - pise se izmedju `(: ... :)`
- **konstante**
    - prazna sekvenca `()`
    - logicke (*xs:boolean*) `true(), false()`
    - stringovi (*xs:string*) `"dokle", "vise"`
    - celi brojevi (*xs:integer*) `42`
    - brojevi u fiksnom zarezu (*xs:decimal*) `42., 4.2, .42`
    - brojevi u pokretnom zarezu (*xs:double*) `42E0, 4.2e+0, 42E-2`
    - drugi tipovi `xs:float("1.25"), xs:ID("X1")`
- **prolog**
    - nije obavezan
    - definiše kontekst za upit (compile-time)
        - namespaces `declare namespace x = "http://www.foo.com"`
        - korisničke funkcije `declare function my:fact($n as xs:integer) as xs:integer {}`
        - importovani šema tipovi
        - importovani moduli
        - promenljive
- rezultat XQuery upita moze biti atomicka vrednost ili XML sadrzaj
- **XML sadrzaj**
    - XQuery se često koristi za generisanje XML dokumenata
        - slično kao u SQL-u (rezultat upita je relacija)
    - XML node constructor `<dokle>vise</dokle>`
    - dinamicko generisanje sarzaja: XQuery izrazi unutar `{ ... }`
        - primer: `<x y="2*2 = {2*2}">Velika istina: 2*2 = {2*2}.</x>`
        - rezultat: `<x y="2*2 = 4">Velika istina: 2*2=4.</x>`
    - navodjenje viticastih zagrada `<add>{{ 1 + 1 = { 1+1 }}}</add>` => `<add>{ 1 + 1 = 2 }</add>`
    - alternativni nacin za knstrukciju elemanata: `element {"ime"} {"sadrzaj"}` => `<ime>sadržaj</ime>`
    - sekvence se poravnavaju pre ugradjivanja u XML
- **operatori**
    - zarez definise sekvencu
        - ima najnizi prioritet pa se sekvence cesto smestaju u zagrade
    - zagrade mogu da grupisu izraze razlicitih tipova
    - logicki operatori `and`, `or`, i `not()`(pise se kao funckija zbog kompatibilnosti sa XPath)
    - *if-then-else* operator
        - else je obavezan
        - `if (true()) then "true" else "false"`
    - aritmeticki
        - binarni: `+, -, *, div, idiv, mod`
        - unarni: `+, -`
    - poredjenje vrednosti za dva singletona: `eq, ne, gt, ge, lt, le`
    - generalno poredjenje - za dve sekvence
        - vraca `true()` ako u obe sekvence postoji bar po jedan element za koji poredjenje po vrednosti vraca `true()`
    - poredjenje cvorova - operisu nad sekvencama cvorova
        - `<<` - "before": vraća true ako je levi čvor ispred/pre desnog u dokumentu
        - `>>` - "after": vraća true ako je levi čvor iza/posle desnog u dokumentu
        - `is` - vraća true ako su čvorovi isti (po identitetu)
        - `isnot` - negacija od is
    - funkcije za poredjenje
        - `compare()`: poredi dve atomicke vrednosti
        - `deep-equal()`: predi cele sekvence, sa dubokim poredjenjem svih elemenata
- **ugradjene funkcije**
    - 110 komada
    - razlikuju se po imenu i listi parametara
    - funkcije nad sekvencama
        - `count()`: dužina sekvence
        - `distinct-values()`: ukloni sve duplikate
        - `empty()`: da li je sekvenca prazna
        - `exists()`: da li sekvenca nije prazna
        - `index-of()`: položaj elementa u sekvenci
        - `insert-before()`: ubaci element u sekvencu
        - `remove()`: ukloni element iz sekvence
        - `reverse()`: obrni redosled sekvence
        - `subsequence()`: izdvoj podsekvencu
        - `unordered()`: naglasi da redosled nije važan
    - aritmeticke funkcije
        - `floor()`
        - `ceiling()`
        - `abs()`
        - `min()`
        - `max()`
        - `avg()`
        - `sum()`
        - `round()`
        - `round-half-to-even()`
<> sintaksni biseri
- **putanje**
    - koristi se neznatno izmenjen [XPath](#xpath)
    - struktura elementa putanje je ista
    - funkcije za navigaciju
        - `collection()`: imenovana sekvenca
        - `doc()`: koren datog XML dokumenta
        - `id()`: element sa datim ID-jem
        - `idref()`: elementi koji pokazuju na dati ID
        - `root()`: koren tekućeg dokumenta
- **promenljive**
    - navode se sa znakom `$` ispred imena
    - ime moze biti nekvalifikovano i kvalifikovano
        - prefiks zamenjuje namespace
    - promenljivama se ne moze menjati vrednost
- **FLWOR izrazi**
    - centralni izraz u XQuery
    - cita se *flower*
    - for, let, where, order by, return
    - namene
        - definisanje promenljivih
        - iteraciju kroz sekvencu
        - filtriranje rezultata
        - sortiranje sekvenci
        - spajanje razlicitih izvora podataka
    - primer
        - `for $i in doc("orders.xml")//Customer`
        - `let $name := concat($i/@FirstName, $i/@LastName)`
        - `where $i/@ZipCode = 91126`
        - `order by $i/@LastName`
        - `return <Customer Name="{$name}">{ $i//Order }</Customer>`
- **kvantifikacija**
    - operatori `some` (postoji) i `every` (za svaki)
    - skraceni FLWOR
    - vracaju logicku vrednost
    - primer: `some $emp in doc("team.xml")//Employee satisfies $emp/@years > 5`
- join
    - *join* funkcionalnosti iz SQL-a se mogu implementirati sablonima
        - dekartov proizvod
        - *inner* *join* (*one-to-one*, *many-to-many*)
        - *outer* *join* (*left*, *right*)
        - self *join*
- **poredjenje sekvenci**
    - egzistencijalno poredjenje
        - uobicajeno poredjenje radi ovo
        - `some()`
    - poredjenje član-po-član
        - `deep-equal()` - ponasa se rekurzivno
        - `shallow-equal()` - ne postoji kao ugradjena funckija (implementacija u slajdovima)
    - univerzalno poređenje - uslov je zadovoljen za svaki element
        - `every()`
- **sortiranje**
    - `order by` - sortira se po datim kljucevima
    - tretiranje prazne sekvence i *NaN*
        - `empty least` - prazna sekvence je manja od svake neprazne; *NaN* je manji od svake ne-*NaN* vrednosti i neprazne sekvence
        - `empty greatest`- prazna sekvenca je veca od svake neprazne; *NaN* je veci od svake *ne-NaN* vrednosti i neprazne sekvence
- grupisanje
    - nema posebnog `group by` operatora
    - rezultujuci XML predstavlja grupisanje
- obrada gresaka
    - statička ili dinamička - zavisno od implementacije
    - `error()` - za programsko izazivanje greske
    - `trace()` - za generisanje poruke o gresci bez prekidanja izvrsavanja

## Vizuelizacija XML Dokumenta
- vizuelizacija XML dokumenta
    - sadrzaj + struktura + prezentacija
    - jedan dokument moze da biti prikazan na vise nacina
        - moze zavisiti od korisnika (npr. autor, urednik, citalac)
        - moze zavisiti od pristupnog uredjaja (npr. web browser, telefon)
    - prikazivanje XML dokumenata oslanja se na neku od postojećih tehnologija (HTML, WDF, PDF, itd.)
    - tehnologije za vizuelizaciju XML dokumenta
        - [CSS](#css) (*Cascading Style Sheets*)
        - XSL (*Extensible Style Sheets*)
            - [XSLT](#xslt) (*XSL Transformations*)
            - [XSL-FO](#xsl-fo) (*XSL Formatting Objects*)
## CSS
- tehnologija za vizuelizaciju pre svega namenjena za HTML
- adaptirana za upotrebu sa XML-om
- HTML je počeo kao jezik za opis strukture dokumenata 
- elementi za formatiranje dodavani su kasnije
- primer: ova dva fragmenta proizvode vizuelno isti rezultat
    - `<h1>Document title</h1>`
    - `<div><font size="7" face="New Times Roman">Document title</font></div>`
    - prva varijana nosi vise semantike nego druga (moze se zakljuciti da je u pitanju naslov najviseg nivoa)
- uveden kako bi se
    - zaustavilo uvođenje novih tagova za formatiranje
    - razdvojila logička struktura dokumenta od njegove prezentacije
    - ustanovio skup atributa koji definišu izgled HTML strane, zajednički za sve web browsere
    - stvorilo sredstvo za prikaz dokumenata na različitim medijima (web browser, papir, PDA, telefoni, govorni uredjaji)
- CSS fajl nije XML dokument, ima sopstvenu sintaksu
- kaskadno - parametri definisani za element A nasledjuju se u svim elementima koje A sadrži
- CSS i XML
    - može se iskoristiti za vizuelizaciju XML dokumenata
    - nije najfleksibilnije rešenje, ali podržan je u svim browserima
    - povezivanje XML dokumenta sa CSS fajlom
        - `<?xml-stylesheet type="text/css" href="fajl.css"?>`
- kada koristiti?
    - kada se web browser koristi za prikaz dokumenata
        - moguće je CSS koristiti i za štampu, ali malo softvera podržava sve CSS funkcije
    - kada je sadržaj dokumenta blizak onome što treba prikazati
        - ukoliko su potrebne transformacije nad podacima u dokumentu CSS se teško može koristiti
- nedostaci
    - nije moguće promeniti redosled elemenata u dokumentu (npr. sortiranje i filtriranje podataka)
    - nisu moguća izračunavanja (proseka, maksimuma, itd.)
    - nije moguće kombinovanje više dokumenata u jedan prikaz

## XSLT
- jezik za opis transformacija XML dokumenata u druge XML
- W3C standard
- za navigaciju koristi XPath izraze
- vizuelizacija - samo jedna od primena
    - kada je rezultat transformacije XHTML
- XSLT je još jedna XML gramatika
- funkcionalnost
    - jedan XML dokument se transformiše u drugi
    - transformacija je opisana XSLT dokumentom
    - transformaciju izvodi XSLT procesor
    - XSLT fajl sadrži definicije **šablona**
        - šablon opisuje transformaciju dela polaznog dokumenta
        - deo polaznog dokumenta se identifikuje XPath izrazom
    - interpretiranje XSLT fajla se svodi na primenu šablona
- `<xsl:stylesheet>` - korenski element svakog XSLT dokumenta
    - atribut `version` - verzija XSLT jezika koja se koristi u fajlu 
    - deklaracija za XSLT namespace, uobičajeni prefiks je xsl
    - sadržaj elementa čine šabloni - `<xsl:template>`
- `<xsl:template>` - definiše šablon
    - atribut `match` sadrži kontekst u kome će se šablon izvršiti
        - kontekst se definiše kao XPath izraz
        - XPath izraz, ako predstavlja relativnu putanju, se izračunava u odnosu na tekući kontekst
        - ako se ne pronađe dati kontekst, šablon se ne izvršava
    - sadržaj elementa se dodaje na kraj rezultujućeg fajla
        - ako se u sadržaju nalaze drugi XSLT elementi, oni se prethodno izračunavaju
- `<xsl:value-of>` - sadržaj datog elementa dodaje u rezultujući dokument
    - atribut `select` predstavlja XPath putanju do željenog elementa
        - ako element ne postoji, ne ubacuje se ništa
        - ako postoji više elemenata za dati XPath, uzima se prvi
    - uvek je prazan
- `<xsl:for-each>` - izdvaja svaki element iz skupa čvorova
    - atribut `select` predstavlja XPath putanju do željenih elemenata
    - sadržaj se dodaje na izlazni fajl za svaki pronađeni element
        - sadržaj se ponovo procesira ako sadrži XSLT elemente
- `<xsl:sort>` - sortira sadržaj tekućeg konteksta prema datom kriterijumu
    - atributi
        - `select` - XPath do čvora čiji sadržaj se koristi kao ključ za sortiranje
        - `data-type` - koji tip podatka se koristi kao ključ (`text`, `number`, `QName`)
        - `order` - opadajući ili rastući redosled (`ascending`, `descending`)
        - `case-order` - prvo velika ili mala slova (`upper-first`, `lower-first`)
        - `lang` - jezik čiji alfabet se koristi za sortiranje (*ISO 639*: *sr*, *en*, *fr*, itd)
    - element je uvek prazan
- `<xsl:if>` - prikazuje svoj sadržaj samo ako je dati uslov ispunjen
    - atribut `test` - uslov koji je potrebno ispuniti
    - primer: `<xsl:if test="price &lt; 10"/>`
- `<xsl:choose>` - izvršava više uzastopnih testova
    - svaki test se opisuje pomoću `<xsl:when>` podelementa
        - atribut test predstavlja sadržaj testa
    - ako nijedan test nije ispunjen, izvršava se `<xsl:otherwise>` podelement
    - poput *switch-case-default*
- `<xsl:apply-templates>` - pokreće ponovnu primenu šablona u okviru tekućeg konteksta
    - ako ima atribut `select` šabloni se primenjuju samo na izabrane podčvorove
- `<xsl:call-template>` - poziva imenovani šablon na datom mestu
    - moze da ima parametre - `<xsl:param name="width"/>`
    - parametri mogu imati podrazumevane vrednosti - `<xsl:param name="bgColor" select="'blue'"/>`
        - moze i unutar elementa kao sadrzaj
    - upotreba parametra `<td width="{$width}" bgcolor="{$bgColor}">`
    - poziv sa parametrom
        - `<xsl:call-template name="addTableCell">`
        - &nbsp;&nbsp;`<xsl:with-param name="width" select="100"/>`
        - `</xsl:call-template>`
- **promenljive**
    - definisanje `<xsl:variable name="x"/>`
        - moze da ima podrazumevanu vrednost
        - moze da sadrzi podelemente poput `<xsl:choose>`
    - upotreba ista kao i kod parametra
    - nije moguce menjati vrednost
    - promenljive su vezane za šablon u kojima su definisane
        - različiti šabloni mogu imati promenljive istog imena
    - globalna promenljiva - dete `<xsl:stylesheet>` elementa
        - vidljiva u svim šablonima koji se nalaze posle njene definicije
         
## XSL-FO
- XML jezik za opis formatiranja straničnih dokumenata
    - radi sa konceptima oblikovanja i raspoređivanja elemenata na stranice
    - originalni XML dokument se mora transformisati u XSL-FO da bi bio prikazan
        - za transformaciju može da se koristi XSLT
    - samo po sebi XSL-FO je XML dokument
    - sadrži opis rasporeda elemenata na stranicama
    - za njegov prikaz potreban je poseban softver za renderovanje
    - najčešće se renderovanje oslanja na neke od rasprostranjenih formata tako što se XSL-FO dokument konvertuje u drugi format (*PDF*, *PostScript*, *PCL(HP)*, *SVG*)
        - XSL-FO *renderer*
- **osnovni pojmovi**
    - *page layout* - raspored stranice
        - fizičke dimenzije, margine, zaglavlje/podnožje, brojevi stranica, itd
    - *block* - površina koju zauzima neki objekat
        - pasus, reč, naslov, slika
    - *inline* - parče teksta koje se prostire u jednom redu
- **Simple page master**
    - XSL-FO može da opiše izgled stranice za stranične medije (štampa) i ne-stranične, kontinualne medije (web)
    - ne-stranični mediji
        - tretiraju se kao mediji sa jednom velikom (dugačkom) stranicom
        - na tu stranicu se gleda kroz prozor, tzv. *viewport*
        - koncepti isecanja (*clipping*), pomeranja prozora (*scrolling*)
    - za stranične medije o ovim detaljima se ne mora voditi puno računa
    - definicija osnovnih parametara
        - `<fo:simple-page-master`
        - &nbsp;&nbsp;`master-name="simple"`
        - &nbsp;&nbsp;`page-height="29.7cm"`
        - &nbsp;&nbsp;`page-width="21cm"`
        - &nbsp;&nbsp;`margin-top="1cm"`
        - &nbsp;&nbsp;`margin-bottom="2cm"`
        - &nbsp;&nbsp;`margin-left="2.5cm"`
        - &nbsp;&nbsp;`margin-right="2.5cm">`
    - atributi iz skupa *common margin properties - block*
        - `margin-top`
        - `margin-bottom`
        - `margin-left`
        - `margin-right`
        - `space-before`
        - `space-after`
        - `start-indent`
        - `end-indent`
    - regioni stranice
        - `<fo:simple-page-master ...>`
        - &nbsp;&nbsp;`<fo:region-body margin-top="1cm"/>`
        - &nbsp;&nbsp;`<fo:region-before extent="3cm"/>`
        - &nbsp;&nbsp;`<fo:region-after extent="1.5cm"/>`
        - &nbsp;&nbsp;`<fo:region-start extent="2cm"/>`
        - &nbsp;&nbsp;`<fo:region-end extent="2cm"/>`
        - `</fo:simple-page-master>`
    - svaki region ima svoje ime
        - ako se ime ne definiše, koristi se podrazumevano ime
    - objekti se dodeljuju regionima preko imena regiona
    - regioni stranice na obodima se dimenzionišu u odnosu na ivicu
    - region `xsl-region-body` (centralni region) ima sopstvene margine
        - one definišu i veličinu i položaj regiona
        - mere se u odnosu na ivicu stranice
        - nema garancije da se ovaj region neće preklapati sa ivičnim regionima (da bi se to izbeglo, njegove margine moraju biti jednake ili veće od dimenzija ivičnih regiona)
    - atribut `writing mode`: način pisanja teksta
        - `lr-tb` (left-to-right, top-to-bottom) ~ evropski jezici
        - `rl-tb` (right-to-left, top-to-bottom) ~ semitski jezici
        - `tb-rl` (top-to-bottom, right-to-left) ~ dalekoistočni jezici
    - atribut `reference-orientation` definiše gde je vrh strane
    - popunjavanje mastera sadržajem
        - sadržaj se nalazi u `<fo:page-content>` elementu
        - sadržaj je grupisan u tokove (*flows*)
        - `<fo:static-content>` - statički sadržaj koji se ponavlja (npr. zaglavlje)
        - `<fo:flow>` - sadržaj koji se ne ponavlja kada se jednom iskoristi
- **Page sequence master**
    - niz različitih formata stranice
        - svaki od tih formata se definiše kao simple page master
    - nizanje različitih mastera na više načina
    - `single-page-master-reference` - dati master će se iskoristiti za tačno jednu stranicu
    - `repeatable-page-master-reference` - dati master će se upotrebiti za onoliko stranica dok se ne potroši tekući *flow* ili za unapred dati maksimalan broj stranica
    - `repeatable-page-master-alternatives` - izbor jednog od mastera zavisno od nekog uslova
        - svaki podelement je referenca na jedan master
        - za svaki podelement je vezan logički uslov (prvi podelement koji ima ispunjen uslov biće iskorišćen za popunu sadržajem)
        - uslovi se izražavaju pomoću tri atributa
            - `page-position`: `first` (prva strana), `last` (poslednja) `rest` (sve ostale), `any` (bilo koja)
            - `odd-or-even`: `odd` (neparna), `even` (parna), `any` (bilo koja)
            - `blank-or-not-blank`: `blank` (prazna), `not-blank` (nije prazna), `any` (bilo koja)
- **Page sequence**
    - predstavlja skup sadržaja obuhvaćenih elementom `<fo:page-sequence>`
    - atributi elementa `<fo:page-sequence>`
        - `master-reference` - ime mastera koji će se primeniti
        - `initial-page-number` - određuje broj prve stranice - `auto`, `auto-odd`, `auto-even`, konkretan broj
        - force-page-count - koliki je ukupan broj stranica - `auto`, `even`, `odd`, `end-on-even`, `end-on-odd`, `no-force`
        - `language` - jezik teksta
        - `country` - država u kojoj se objavljuje dokument
- Prikazani sadržaj čine objekti (*objects*)
    - oni zauzimaju prostor koji se izražava pomoću pojmova
        - površine (*area*)
        - bloka (*block*)
        - reda (*inline*)
- **Area**
    - *area* - pravougaona površina koja ima skup osobina
        - osobine (*traits*) imaju konkretne vrednosti koje odredi XSL-FO renderer
        - atributi (*attributes*) nisu osobine - oni predstavljaju ograničenja u okviru kojih se određuju vrednosti osobina
    - svaka površina se sastoji iz
        - *content rectangle*: deo za sadržaj
        - *padding rectangle*: prostor za odvajanje sadržaja od okvira
        - *border rectangle*: okvir
    - vrste površina
        - *inline area*: parče teksta, ubačena slika (inline površine se nižu jedna za drugom u pravcu `inline-progression-direction`)
        - *block area*: pasus, tabela, lista, ... (block površine se nižu jedna za drugom u pravcu `block-progression-direction`)
        - *glyph area*: jedno slovo
        - *region reference area*: svaki od pet regiona je i površina
    - pozicioniranje površina - određeno atributima
        - `break-before: auto, column, page, odd-page, even-page`
        - `break-after`
        - `keep-with-previous.within-line`: `auto`, `always`, *broj* (mera jačine ograničenja)
        - `keep-with-previous.within-column`
        - `keep-with-previous.within-page`
        - `keep-with-next`
        - `keep-together`
    - dimenzije
        - `inline-progression-dimension`
        - `block-progression-dimension`
        - mogu se eksplicitno postaviti samo za reference areas i slike
    - nizanje blok površina
        - `space-above`: `.minimum`, `.maximum`, `.optimal`
        - `space-below`
        - `precedence`: broj ili force (jačina ograničenja)
        - `conditionality`: `discard`, `retain` (kada nema susedne površine u istoj referentnoj površini)
- **Block**
    - osnovna gradivna jedinica za sadržaj na stranici
        - npr. pasus, tabela, lista, slika
    - blok se sastoji od jedne ili više površina
    - blok sadrži
        - druge blokove
        - jednolinijske fragmente (inline)
        - tekst
    - prelazak na novu stranicu
        - `break-before`: `auto`, `column`, `page`, `even-page`, `odd-page`
        - `break-after`
    - uvlačenje bloka
        - `padding-before`, `padding-after`,` padding-start`, `padding-end`
- *Lista*
    - lista je vrsta bloka
    - struktura: `<fo:list-block>` => `<fo:list-item>` => `<fo:list-item-label>` ^ `<fo:list-item-body>`
- *Tabela*
    - tabela je vrsta bloka
    - struktura: `<fo:table>` => `<fo:table-header>` ^ `<fo:table-body>` => `<fo:table-row>` => `<fo:table-cell>`
    - tabela i potpis `<fo:table-and-caption>` => `<fo:table-caption text-align="center">` ^ `<fo:table>`
- **Inline**
    - jednolinijski fragmenti
        - *bold*, *italic*, itd.
- *Slike*
    - slike su inline elementi
        - ako je potrebno mogu se obuhvatiti u block
    - mogu se ubaciti na dva načina
        - kao eksterni ne-XML sadržaj (npr. JPEG slika) `<fo:external-graphic src="url(images/pic.jpg)">`
        - kao eksterni XML sadržaj (npr. SVG slika) `<fo:instream-foreign-object src="url(images/pic.svg)"`
- *Boja*
    - definisanje boje
        - po imenu: `red`, `blue`, ...
        - RGB model: `#rrggbb` ili `#rgb`
        - po imenu koje je specifično za konkretnu rač. platformu
        - drugi modeli za koje postoji ICC profil `<fo:declarations>` => `<fo:color-profile src="url('./myprofile.icc')" color-profile-name="mycp"/>`
            - `<fo:block color='icc-color(200, 200, 50, mycp, 1.45, 2.22)'>`
- *Fontovi*
    - XSL-FO usvaja OpenType model fonta
    - atributi: `font-family, font-style, font-variant, font-weight, font-stretch, font-size`
    - font mora biti dostupan XSL-FO procesoru
- *Linkovi* - element `<fo:basic-link>`
    
## RDF
- uvodna terminologija
    - podaci (skup simbola koji predstavljaju svojstva objekata, dogaaja ili njihovog okruženja)
    - informacije (podaci organizovani tako da imaju znacenje)
    - znanje (informacije organizovane tako da mogu da se koriste za donošenje odluka)
    - narativni dokumenti (slabo strukturirani)
    - transakcioni dokumenti (jako strukturirani)
    - povezani dokumenti (world wide web)
    - povezani podaci (semantic web, web 3.0)
- **Linked Data**  predstavlja nacin objavljivanja podataka na (semantickom) webu
    - ohrabruje ponovno korišcenje podataka
    - smanjuje redudantnost
    - maksimizira (pravu i potencijalnu) povezanost izmeu podataka
    - omogucava stvaranje "mrežnog efekta" i dodaje vrednost podacima
    - principi
        - Koristiti URI za imena stvari
        - Koristiti HTTP URI da bi stvari mogle da se pronadju
        - Kada neko traži resurs, ponuditi odgovor u RDF formatu
        - U odgovor ukljuciti RDF iskaze koji povezuju traženi resurs sa drugim resursima da bi mogle da se pronau srodne stvari
- **RDF Graph**
    - RDF (Resource Description Framework) je standardni model za razmenu podataka na WWW
    - Proširuje WWW (mrežu dokumenata) tako što koristi URI za imenovanje stvari i njihovih odnosa (i na taj nacin formira mrežu podataka)
    - Ova struktura formira usmeren oznacen graf (ciji su cvorovi resursi i literali, a grane relacije izmeu njih)
    - Graf se može predstaviti kao skup iskaza oblika oblika **`<subjekat> <predikat> <objekat>`**
- **Semantic web stek**
    - XML pruža sintaksu za strukturiranje dokumenata, ali ne namece semanticka ogranicenja na znacenje takvih dokumenata
    - XML Schema je jezik za ogranicavanje strukture XML dokumenata i takoe proširuje XML sa tipovima podataka
    - RDF je model podataka za objekte ("resurse") i odnose izmeu njih, pruža jednostavnu semantiku za ovaj model podataka, i omogucava da se model podataka predstavi u XML sintaksi
    - RDF Schema je recnik za opis klasa i svojstava RDF resursa, sa semantikom poput specijalizacije i generalizacije takvih klasa i svojstava
- motivacija iza RDF-a
    - Problem u pretraživanju iste semantike predstavljene razliciti XML stablima
    - Upit treba da bude nezavisan od nacin na koji je predstavljena semantika
    - Potreba za pretvaranjem svih mogucih predstava semantike u jedan iskaz
- **RDF**
    - Standardizovani nacin za pisanje iskaza
    - Kako god da se ista semantika pojavi u XML dokumentima, predstavljena je na isti nacin RDF iskazima
    - Više XML stabala može da odgovara jednom RDF grafu
    - Resource Description Framework (RDF) je još jedna World Wide Web Consortium (W3C) specifikacija
    - To je graf bazirani model podataka za opisivanje stvari (resursa) i njihovih meusobnih odnosa
    - Omogucava interoperabilnost izmedju aplikacija koje razmenjuju mašinski citljive i razumljive podatke na webu
- **RDF iskaz**
    - **subjekat** (resurs)
    - **predikat** (svojstva)
    - **objekat** (resursa ili literala)
- Resursi
    - Stvari koje se opisuju sa RDF
    - [definicija](#inzenjering-dokumenata)
    - identifikuju se sa IRI(*Internationalized Resource Identifier* - prosirenje URL sa UCS karakterima)
- Svjostva
    - Specificni aspekti, karakteristike, atributi ili odnosi korišceni za opis resursa
    - Vrednost svojstva može biti resurs ili literal
    - Identifikuju se sa IRI
- Literali
    - (tipizirane) konstante
    - XML Schema tipovi podataka
    - ISO kodovi jezika
- URI
    - Za identifikaciju resursa, svojstava i tipova podataka koriste se [URI](#inzenjering-dokumenata)
- konkretne sintakse za RDF
    - *Turtle* (*Terse RDF Triple Language*)
        - konkretna sintaksa za RDF
        - Tekstualna serijalizacija RDF grafa
        - Kompaktna, lako citljiva forma
    - *RDF/XML*
        - Tekstualna XML serijalizacija RDF grafa
        - Obezbeuje maksimalnu interoperabilnost
    - *RDFa* (RDF in attributes)
        - Omogucava ugraivanje RDF iskaza u XML dokumente pomocu standardizovanih atributa
- *GRDDL*
    - *Gleaning Resource Descriptions from Dialects of Languages* (GRDDL) je W3C specifikacija koja olakšava ekstrakciju RDF iskaza iz XML dokumenata
    - Obicno se RDF iskazi u RDFa formatu transformišu u RDF iskaze u RDF/XML formatu korišcenjem XSLT transformacije
- *Linked data*
    - Linked data je skup principa za objavljivanje, pronalaženje i pregledanje podataka u RDF formatu (ti podaci mogu biti distribuirani na više servera)
    - Linked data je korišcenje mreže za povezivanje srodnih podataka koji nisu povezani ili smanjivanje barijere za povezivanje podataka koji su povezani korišcenjem drugih metoda
- Linked Data in the Wild
    - *Schema.org*
        - projekat ciji je cilj stvaranje, održavanje i promovisanje šeme za strukturirane  podatke na internetu
        - Omogucava web stranama da oznace metapodatke u RDFa, JSON-LD i microdata formatima
        - Podržan je od strane vodecih web pretraživaca (Google, Yahoo, Bing, Yandex) koji  prepoznaju metapodatke i na taj nacin dobijaju pristup znacenju web strana
        - Schema.org je deljena kolekcija microdata šema koja ukljucuje hijerarhiju tipova (kao     RDF šema)
    - *DBPedia*
        - crowdsourcing projekat ciji je cilj da ekstahuje strukturiran sadržaj iz informacija  koje sa nalaze u Wikipedia-ji
        - sadržaj se objavljuje u RDF formatu
        - Omoguceno je postavljanje [SPARQL](#sparql) upita nad DBPedia skupom podataka (i  drugim srodnim skupovima podataka)
    - *Open Graph*
        - omogucava integraciju web strana u Social Graph dodavanjem metapodataka u RDFa formatu
        - Podatke u Open Graph formatu, izmeu ostalih, objavljuju IMDb, Microsoft, NHL, Posterous, Rotten Tomatoes, TIME i YelpIt, a koriste Facebook i Google
    - *Knowledge Graph*
        - baza znanja koju koristi Google da bi obogatio web pretragu
        - Tvrdi se da je Knowledge Graph u oktobru 2016 sadržao više od 70 milijardi cinjenica o ljudima, mestima i stvarima
        - Cinjenice su predstavljene kao strukturirane informacije za linkovima ka drugim cinjenicama

## RDFS
- RDFS (RDF Schema) je semanticko proširenje RDF
- Omogucava definisanje domenski specificnih klasa i svojstava
- RDF Schema se zapisuje u RDF formatu
- RDF Schema vs. XML Schema
    - XML Schema deklariše elemente i atribute dokumenata odreenog tipa
    - RDFS definiše klase i svojstva u domenski specificnom semantickom modelu
    - XML Schema zadaje ogranicenja nad strukturom XML dokumenta (može se definisati domenski specificna struktura
    - RDF Schema zadaje "znacenje" RDF iskaz (mogu se definisati domenski specificne klase i svojstva)
- **OWL** (*Web Ontology Language*)
    - može se koristiti za eksplicitno predstavljanje znacenja termina i odnosa izmedju tih termina
    - Pruža formalan opis koncepata, termina, i odnosa u zadatom domenu
    - OWL ima više mogucnosti za izražavanje znacenja i semantike od XML, RDF i RDFS
    - Ova predstava termina i njihovih meusobnih odnosa zove se ontologija
- **Klasa**
    - Klasa u RDFS je slicna klasi u objektno-orijentisanim programskim jezicima (skup slicnih resursa)
    - vrste
        - `rdfs:Resource` - instance ove klase su resursi
        - `rdfs:Class` - instance ove klase su klase
        - `rdfs:Literal` - instance ove klase su vrednosti svojstva koje su tipizirane konstante
        - `rdf:Property` - instance ove klase su svojstva
- **Svojstvo**
    - Svojstva su (bitne) osobine resursa
    - Za razliku od objektno-orijentisanih programskih jezika, svojstva su "ravnopravna" sa klasama (takodje su resursi i takodje se mogu nasleivati)
    - atributi
        - `rdf:type` - tip resursa (klasa ciji je resurs instanca)
        - `rdfs:subClassOf` - klasa je specijalizacija klase
        - `rdfs:subPropertyOf` - svojstvo je specijalizacija svojstva
    - ogranicenja (u vidu atributa)
        - `rdfs:domain` - domen svojstva
        - `rdfs:range` - kodomen svojstva
- **Anotacije**
    - `rdfs:comment` - opis resursa (human-readable)
    - `rdfs:label` - ime resursa (human-readable)
    - `rdfs:seeAlso` - resurs koji pruža dodatne informacije o resursu
    - `rdfs:isDefinedBy` - resurs koji definiše resurs

## SPARQL
- upitni jezik za postavljanje upita nad podacima u RDF formatu
- SPARQL je protokol za postavljanje upita nad udaljenim RDF skladištima preko HTTP protokola
- SPARQL (kao upitni jezik) omogucava:
    - Ekstrakciju podataka iz strukturiranih i polustrukturiranih izvora
    - Transformaciju podataka u RDF formatu iz jednog recnika u drugi
    - Izvršavanje složenih join operacija u jednom jednostavnom upitu
- **Upiti**
    - izvršavaju se nad RDF grafovima
    - nad raznorodnim izvorima podataka
        - podaci izvorno skladišteni u RDF formatu
        - podaci skladišteni u drugom formatu (XML, HTML, RDB) koje middleware transformiše u RDF format
    - vrste
        - `SELECT` - vraca promenljive u tabelarnom obliku
        - `CONSTRUCT` - vraca RDF graf konstruisan na osnovu promenljivih
        - `ASK` - vraca logicku vrednost koja oznacava da li ekvivalentan `SELECT` upit vraca rezultat
        - `DESCRIBE` - vraca RDF graf koji opisuje resurs
    - struktura
        - Deklaracija prefiksa (skracivanje URI)
        - Definicija izvora podataka (RDF grafova nad kojima ce se izvršiti upit)
        - Klauzula rezultata (specifikacija podataka koje ce upit vratiti)
        - Obrazac grafa (specifikacija restrikcija nad podacima)
        - Modifikatori upita (isecanje, sortiranje, grupisanje i drugo modifikovanje rezultata)
- **Obrazac grafa**
    - SPARQL pomenljive pocinju sa ? i mogu da se poklapaju sa bilo kojim cvorom (resursom ili literalom) ili vezom u RDF grafu
    - Obrasci trojki su trojke u kojima je bilo koji element (subjekat, predikat ili objekat) zamenjen sa promenljivom
    - Obrazac grafa je skup obrazaca trojki (koji mogu biti filtrirani logickim izrazima) i modifikovani `OPTIONAL` i `UNION` kljucnim recima
- `FILTER` primenjuje operator/funkciju na rezultat
    - tabela operatora i funkcija na slajdovima
- **FROM NAMED**
    - SPARQL upiti se izvršavaju nad RDF skupovima podataka koji se sastoje iz RDF grafova
    - RDF skupovi podataka sastoje se iz podrazumevanog grafa i nula ili više imenovanih grafova (identifikovanih sa URI)
    - Imenovani grafovi mogu se specificirati sa `FROM NAMED` klauzulom
    - `GRAPH` klauzula omogucava da se delovi upita poklapaju sa imenovanim grafovima u RDF skupu podataka (sve izvan `GRAPH` klauzule se poklapa sa podrazumevanim grafom)
- *Rezultati* se mogu vartiti u razlicitim formatima
    - XML (SPARQL Query Results XML Format)
        - Serijalizuje rezultat SPARQL `SELECT` i `ASK` upita u XML
        - Rezultat `SELECT` upita je tabela (slicna HTML table elementu)
        - Rezultat ASK upita je logicka vrednost
    - JSON (SPARQL 1.1 Query Results JSON Format)
        - Serijalizuje rezultat SPARQL `SELECT` i `ASK` upita u JSON
        - Rezultat `SELECT` upita je tabela serijalizovana u niz (elementi niza su vrste tabele)
        - Rezultat `ASK` upita je logicka vrednost
    - CSV/TSV (SPARQL 1.1 Query Results CSV and TSV Formats)
        - Rezultat `SELECT` upita može se serijalizovati i u CSV i TSV format
        - Pogodno za uvoz podataka u Excel, RDBMS, itd.
    - RDF (može se serijalizovati u više formata)
    - HTML (kada se sa SPARQL upitima radi u interaktivnom modu)
- `CONSTRUCT` upit
    - alternativa `SELECT` upitu koja vraca RDF graf umesto tabele
    - RDF graf se konstruiše tako što se uzimaju rezultati ekvivalentnog `SELECT` upita i sa njima zamenjuju vrednosti promenljivih u obrascima u `CONSTRUCT` klauzuli
    - U RDF grafu se ne konstruišu trojke za obrasce u kojima se nalaze nevezane promenljive
- `ASK` upit
    - vraca logicku vrednost u zavisnosti od toga da li se obrazac poklapa sa nekim (bilo kojim) skupom podataka
    - Kao i kod `SELECT` upita, rezultati su podrazumevano kodirani u XML formatu
- `DESCRIBE` upit
    - upit vraca RDF graf koji opisuje zadati resurs
    - Nisu interoperabilni zato što razliciti serveri mogu da ih interpretiraju na razlicite nacine
- *RDF skladista (triplestores)*
    - Skladište podatke izvorno u RDF obliku (kao RDF graf ili skup RDF trojki/iskaza)
    - Omogucavaju izvršavanje SPARQL upita nad podacima koje skladište
    - Indeksiranjem su optimizovani za izvršavanje upita nad grafovima
- *SPARQL krajnje tacke (endpoints)*
    - prima zahteve i vraca odgovore preko HTTP protokola (SPARQL protokol ili RESTful)
        - Genericke krajnje tacke omogucavaju izvršavanje upita nad bilo kojim RDF skupom podataka dostupnim na mreži
        - Specificne krajnje tacke su podešene za izvršavanje upita nad tacno odreenim skupom podataka
    - Podaci mogu bili skladišteni u RDF skladištima, ali i u drugim vrstama skladišta (RDBMS, XML, itd.) kojima se pristupa preko middleware
- *MarkLogic*
    - Komercijalna enterprise NoSQL baza podataka
    - Skladištenje i pretraživanje podataka u XML, RDF i JSON formatu
    - Podrška za ACID transakcije
    - Distribuirana arhitektura koja lako skalira
- *Jena*
    - Java framework otvorenog koda za skladištenje, izvršavanje upita i rezonovanje sa podacima u RDF formatu
    - Serijalizacija i deserijalizacija RDF u RDF/XML, N3, N-Triples, itd
    - Skladištenje podataka u memoriji i na disku
    - Izvršavanje SPARQL upita
    - Podrška za OWL (Web Ontology Language) korišcenjem internih rezonera i Pellet rezonera
- *RDF4J (Sesame)*
    - Sesame je framework otvorenog koda za skladištenje RDF podataka i izvršavanje upita nad njima
    - Sadrži implemantaciju RDF skladišta u memoriji i na disku
    - Sesame RDF Input/Output paket sadrži Java API za serijalizaciju i deserijalizaciju RDF podataka u/iz popularnih formata
    - Podrška za SPARQL and SeRQL

## Poslovni procesi
- Poslovni proces je skup aktivnosti koje jedan ili više ulaza transformišu u jedan ili više izlaza radi ostvarivanja planiranog cilja
- Ulazi i izlazi mogu biti informacije (dokumenti)
- svojstva
    - Poslovni procesi mogu se izvršavati od nekoliko sekundi, preko nekoliko meseci, do nekoliko godina (radni tokovi su dugotrajne transakcije)
    - Poslovni procesi mogu se sastojati od drugih poslovnih procesa (radni tokovi su ugnježdene transakcije)
    - Redosled aktivnosti u poslovnom procesu može, a ne mora biti definisan (mogu se izvršavati konkurentno)
    - Nivo automatizacije poslovnih procesa varira (mogu se izvršavati automatski, poluautomatski ili rucno)
- primeri: Izrada diplomskog rada, Kupovina robe, Obavljanje lekarskog pregleda, Dobijanje graevinske dozvole, Donošenje skupštinske odluke
- **aktivnosti**
    - atomicki koraci poslovnog procesa na posmatranom nivou apstrakcije
    - primeri: Odbrana diplomskog rada, Placanje, Zakazivanje lekarskog pregleda, Podnošenje zahteva za izdavanje graevinske dozvole, Glasanje u pojedinostima
- [dokumenti](#inzenjering-dokumenata)
- **Agenti i uloge**
    - Agent je osoba potrebna za izvšavanje aktivnosti
    - Uloga je sposobnost agenta za izvršavanje odredjene aktivnosti
    - Jedan agent može imati više uloga, može postojati hijerarhija uloga
    - primeri: Student, Prodavac, Lekar, Preduzetnik, Odbornik
- Sistemi za upravljanje radnim tokovima / poslovnim procesima
    - omogucavaju definisanje, izvršavanje i nadgledanje izvršavanja radnih tokova
    - Nazivaju se i sistemi za upravljanje radnim tokovima bazirani na dokumentima
- **modelovanje poslovnih procesa**
    - sta?
        - Analiza poslovnih procesa
        - Sinteza poslovnih procesa
    - zasto?
        - Automatizacija poslovnih procesa
        - Poboljšanje poslovnih procesa
        - Reinženjering poslovnih procesa
    - kako?
        - (UML) dijagram aktivnosti
        - Business Process Modelling Notation (BPMN) dijagram
- **model poslovnih procesa**
    - Sastoji se od skupa aktivnosti i ogranicenja nad tim skupom (predstavlja aktivnosti i njihove meusobne odnose)
    - Može se koristiti za komunikaciju izmeu ucesnika u razvoju informacionih sistema ili za konfiguraciju sistema za upravljanje radnim tokovima / poslovnim procesima
    - Graficka reprezentacija poslovnih procesa fokusira se na strukturu procesa i interakciju izmeu agenata (umesto tehnickih aspekata)
- *UML dijagram aktivnosti*
    - UML dijagrami aktivnosti mogu se koristiti za modelovanje poslovnih procesa / radnih tokova
    - Prikazuju niz aktivnosti, od pocetne tacke poslovnog procesa do krajnje tacke poslovnog procesa, detaljno opisujuci tok kontrole
    - UML dijagrami aktivnosti opisuju sekvencijalni ili konkurentni tok aktivnosti u sistemu

## SOA
## SOAP
## WSDL
## UDDI
## Mikroservisi
